
# 📚 트리

## 📌 [문제링크](https://www.acmicpc.net/problem/4803)

### 문제 해설

- 입력은 여러 개의 테스트 케이스로 이루어져 있다.
- 각 테스트 케이스의 첫째 줄에는 노드의 개수와 간선의 갯수가 주어지고, 그 이후 간선의 개수만큼 간선정보가 주어진다.
- 입력의 마지막 줄에는 0이 두 개 주어진다.
- 각 테스트 케이스마다 트리의 개수를 구하는 문제.

### 문제 풀이

- 입력 문제로 애를 많이 먹었다.
- bfs 탐색으로 풀었다.
- 그래프 판별 기준은 탐색을 진행할 때마다. 방문하는 노드가 이미 방문했던 바로 직전노드가 아니면 그래프이다.

```
import sys
from collections import deque
input = sys.stdin.readline
case = 0

while True:
    n,m = map(int,input().split())
    if n == 0 and m == 0: break
    answer = 0
    case += 1
    graph = [ [] for _ in range(n+1) ]
    visited = [ False ] * (n+1)
    for _ in range(m):
        a,b = map(int,input().rstrip().split())
        graph[a].append(b)
        graph[b].append(a)
    
    for i in range(1,n+1):
        if not visited[i]:
            visited[i] = True
            flag = False
            q = deque()
            q.append((-1,i))
            
            while q:
                prev,now = q.popleft()
                
                for nxt in graph[now]:
                    if visited[nxt] == True and prev != nxt:
                        flag = True
                    if not visited[nxt]:
                        visited[nxt] = True
                        q.append((now,nxt))
            if flag:
                continue
            else:
                answer += 1

    if answer == 0:
        print(f'Case {case}: No trees.')
    elif answer == 1:
        print(f'Case {case}: There is one tree.')
    else :
        print(f'Case {case}: A forest of {answer} trees.')
```
