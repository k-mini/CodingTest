
# ðŸ“š êµ¬ìŠ¬ íƒˆì¶œ 2

## ðŸ“Œ [ë¬¸ì œë§í¬](https://www.acmicpc.net/problem/13460)

### ë¬¸ì œ ìš”ì•½

- N x M í¬ê¸°ì˜ ë³´ë“œê°€ ìžˆë‹¤.
- ë³´ë“œì˜ ê° ë¬¸ìžëŠ” '.'(ë¹ˆ ì¹¸), '#'(ìž¥ì• ë¬¼,ë²½), 'O'(êµ¬ë©ì˜ ìœ„ì¹˜), 'R'(ë¹¨ê°„ êµ¬ìŠ¬), 'B'(íŒŒëž€ êµ¬ìŠ¬)ë¡œ ì´ë£¨ì–´ì ¸ ìžˆë‹¤.
- ë¹¨ê°„ êµ¬ìŠ¬ì„ êµ¬ë©ì„ í†µí•´ì„œ ë¹¼ë‚´ë ¤ê³  í•œë‹¤. ë‹¨, íŒŒëž€ êµ¬ìŠ¬ì€ êµ¬ë©ì— ë“¤ì–´ê°€ë©´ ì•ˆëœë‹¤.
- êµ¬ìŠ¬ì„ ì†ìœ¼ë¡œ ì›€ì§ì¼ ìˆœ ì—†ê³ , ë³´ë“œë¥¼ ê¸°ìš¸ì—¬ì„œ ì›€ì§ì¼ ìˆ˜ ìžˆë‹¤.
- ë¹¨ê°„ êµ¬ìŠ¬ê³¼ íŒŒëž€ êµ¬ìŠ¬ì´ ë™ì‹œì— êµ¬ë©ì— ë¹ ì ¸ë„ ì‹¤íŒ¨.
- ë³´ë“œì˜ ìƒíƒœê°€ ì£¼ì–´ì¡Œì„ ë•Œ, ìµœì†Œ ëª‡ ë²ˆ ë§Œì— ë¹¨ê°„ êµ¬ìŠ¬ì„ êµ¬ë©ì„ í†µí•´ ë¹¼ë‚¼ ìˆ˜ ìžˆëŠ”ì§€ êµ¬í•˜ë¼. 

### ë¬¸ì œ í’€ì´

ë¬¸ì œë¥¼ ì½ê³  êµ¬í˜„í•´ì•¼ í•  ê¸°ëŠ¥ 
  1. ë³´ë“œë¥¼ ê¸°ìš¸ì´ë©´ ì´ë™í•˜ëŠ” ê¸°ëŠ¥
- ìœ„ì˜ ê¸°ëŠ¥ì—ì„œ êµ¬ìŠ¬ì„ ì´ë™ì‹œì¼œ ì£¼ëŠ”ë°, êµ¬ìŠ¬ì˜ ì„œë¡œ ë¶€ë”ªí˜€ì„œ ì›€ì§ì´ì§€ ëª»í•˜ëŠ” ê²½ìš°ë¥¼ êµ¬í˜„í•˜ëŠ”ë° ì–´ë ¤ì›€ì„ ê²ªì—ˆë‹¤.  
ex) ê°™ì€ ì¤„ì— ìžˆëŠ” êµ¬ìŠ¬ì„ ê¸°ìš¸ì˜€ì„ ë•Œ, í•œê°œì˜ êµ¬ìŠ¬ì„ 1ì¹¸ ëœ ì´ë™ì‹œì¼œì¤˜ì•¼ í•œë‹¤.  
- ì´ëŸ¬í•œ ë¬¸ì œë¥¼ í•´ê²°í•˜ê¸° ìœ„í•´ êµ¬ìŠ¬ì˜ ì´ë™ì¹¸ ìˆ˜ë¥¼ ì„¸ì–´ì¤€ ë’¤, ë” ë§Žì´ ì´ë™í•œ êµ¬ìŠ¬ì€ í•œ ì¹¸ ë’¤ë¡œ ì´ë™í•œë‹¤.  
(ë” ë§Žì´ ì´ë™í–ˆë‹¤ëŠ” ê±´ ì´ë™í•˜ë ¤ëŠ” ë°©í–¥ì—ì„œ ë©€ë¦¬ ë–¨ì–´ì§„ êµ¬ìŠ¬ì´ë¼ëŠ” ê±¸ ìœ ì¶”í•  ìˆ˜ ìžˆë‹¤. )

- ë³´ë“œì˜ íŠ¹ì • ìƒíƒœë¥¼ ì´ë¯¸ ë°©ë¬¸í–ˆëŠ”ì§€ë¥¼ ì²´í¬í•˜ê¸° ìœ„í•´ ë¹¨ê°„ êµ¬ìŠ¬ê³¼ íŒŒëž€ êµ¬ìŠ¬ì˜ ìœ„ì¹˜ë¥¼ ì²´í¬í•˜ëŠ” visitedë¥¼ ìž‘ì„±


```
import sys
from collections import deque

input = sys.stdin.readline

n,m= map(int,input().split())
board = [list(input().strip()) for _ in range(n)]
visited = [[[ [False] * m for _ in range(n) ] for _ in range(m)] for _ in range(n)]
dx,dy = (-1,0,1,0),(0,1,0,-1)
q = deque()

def init():
    rx, ry, bx, by = [0] * 4
    for i in range(n):
        for j in range(m):
            if board[i][j] == 'R':
                rx, ry = i,j
            elif board[i][j] == 'B':
                bx, by = i,j
    q.append((rx,ry,bx,by,1))
    visited[rx][ry][bx][by] = True
                
def move(x,y,dx,dy):
    count = 0
    while board[x+dx][y+dy] != '#' and board[x][y] != 'O':
        x += dx
        y += dy
        count += 1
    return x, y, count
                
def bfs():
    init()
    while q:
        rx, ry, bx, by, depth = q.popleft()
        if depth > 10:
            break
        for k in range(4):
            next_rx,next_ry, r_count = move(rx,ry,dx[k],dy[k])
            next_bx,next_by, b_count = move(bx,by,dx[k],dy[k])
            
            if board[next_bx][next_by] == 'O': 
                continue
            
            if board[next_rx][next_ry] == 'O':
                print(depth)
                return
            if next_rx == next_bx and next_ry == next_by :
                
                if r_count > b_count :
                    next_rx -= dx[k]
                    next_ry -= dy[k]
                else:
                    next_bx -= dx[k]
                    next_by -= dy[k]
            
            if not visited[next_rx][next_ry][next_bx][next_by]:
                visited[next_rx][next_ry][next_bx][next_by] = True
                q.append((next_rx,next_ry,next_bx,next_by,depth+1))
    print(-1)
    
bfs()
```
