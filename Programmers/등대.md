

### 등대

---

[문제링크](https://school.programmers.co.kr/learn/courses/30/lessons/133500)

인천 앞바다에는 1부터 n까지 서로 다른 번호가 매겨진 등대 n개가 존재합니다. 등대와 등대 사이를 오가는 뱃길이 n-1개 존재하여, 어느 등대에서 출발해도 다른 모든 등대까지 이동할 수 있습니다. 
등대 관리자 윤성이는 전력을 아끼기 위하여, 이 중 몇 개의 등대만 켜 두려고 합니다. 하지만 등대를 아무렇게나 꺼버리면, 뱃길을 오가는 배들이 위험할 수 있습니다. 
한 뱃길의 양쪽 끝 등대 중 적어도 하나는 켜져 있도록 등대를 켜 두어야 합니다.

예를 들어, 아래 그림과 같이 등대 8개와 7개의 뱃길들이 있다고 합시다. 이 경우 1번 등대와 5번 등대 두 개만 켜 두어도 모든 뱃길은 양쪽 끝 등대 중 하나가 켜져 있으므로, 
배들은 안전하게 운항할 수 있습니다.

<img src="https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/f8f83817-2d81-41ec-ab2f-64b19abf7dfb/image7_1.PNG" />

등대의 개수 n과 각 뱃길이 연결된 등대의 번호를 담은 이차원 배열 lighthouse가 매개변수로 주어집니다. 
윤성이가 켜 두어야 하는 등대 개수의 최솟값을 return 하도록 solution 함수를 작성해주세요.


나의풀이:

일단 뱃길이 n-1라는 점이 신경쓰였는데 몇 번 그리면서 확인해보니까 순환구조로 이루어지면 n-1이 될 수 없다. 예를들어 3개의 노드를 삼각형처럼 이루도록 하면 3개의 노드에
3개의 간선이 생기므로 모순이다. 따라서 가지구조가 아닐까 하는 생각이 들었다.

그래서 단순하게 두개의 노드 사이에 우선 최소 한개는 켜져야 되므로 1번노드를 켜주고 1번노드와 이어지는 노드들은 꺼주는 식으로 진행했는데, 이 경우에 만약

루트노드가 자식수를 한개 가지고 있고 자식노드의 자식수가 여러개면 비효율적이다. 

그래서 말단노드부터 탐색을 시작 했다.

```
from collections import deque
def solution(n, lighthouse): 
    # 뱃길이 n-1개다. 1개에서 뱃길을 한개씩 추가할수록 등대가 하나씩 는다고 가정하면
    # 등대는 가지구조를 이루고 있다.
    graph = [ [] for _ in range(n+1)]
    for a,b in lighthouse: 
        graph[a].append(b) 
        graph[b].append(a)
    
    result = 0
    q= deque()
    
    for i in range(1,len(graph)):
        if len(graph[i]) == 1:
            root = i
            break
        
    for child in graph[root]:
        q.append((child,root,False)) # 현재노드, 부모노드,부모노드의 등대 켜짐 여부
    
    # 부모와 자식사이에 둘다 꺼져있는건 x 둘중하나 or 둘다 켜져있어야함.(둘다켜지는경우는 자식노드가 분기점일때 )
    while q:
        node,p_node,p_onoff = q.popleft()
        #print(node,p_node,p_onoff)
        
        if p_onoff == True: # 부모노드가 켜졌으면 끈다. 대신 자식이 여러개이면 킨다.
            if len(graph[node]) >= 3: # 분기점이면
                onoff = True
                result += 1
            else:
                onoff = False
        else: # 부모노드가 꺼져있으면 무조건킨다
            onoff = True
            result += 1

        for c_node in graph[node]:
            if c_node == p_node:
                continue
            else:
                q.append( (c_node,node,onoff) )
        
    return result 
```
 
 말단 노드를 찾아서 일단 등대를 꺼주고 시작했다. 예시 테스트케이스는 통과했는데, 제출해보니 문제가 많았다. 반례가 뭔지 잘 생각이 나지 않았다.
 
 좀 더 고민해보자..


