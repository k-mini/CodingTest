
# ğŸ“š ì„¬ ì—°ê²°í•˜ê¸°

## ğŸ“Œ [ë¬¸ì œë§í¬](https://school.programmers.co.kr/learn/courses/30/lessons/42861)

### ë¬¸ì œ í•´ì„¤

- nê°œì˜ ì„¬ì´ ì£¼ì–´ì§€ê³ , ì„¬ê³¼ ì„¬ ì‚¬ì´ì— ë‹¤ë¦¬ë¥¼ ê±´ì„¤í•˜ëŠ” ë¹„ìš©ì´ ì£¼ì–´ì§ˆ ë•Œ ìµœì†Œì˜ ë¹„ìš©ìœ¼ë¡œ ëª¨ë“  ì„¬ì„ í†µí–‰ê°€ëŠ¥í•˜ê²Œ ë§Œë“¤ì–´ì•¼ í•œë‹¤.
- ì´ ë•Œì˜ ìµœì†Œ ë¹„ìš©ì„ return í•˜ëŠ” ë¬¸ì œì´ë‹¤.

### ë¬¸ì œ í’€ì´

ìœ ë‹ˆì˜¨íŒŒì¸ë“œë¥¼ ì˜ˆì „ì— í•œ ë²ˆ í’€ì–´ë³¸ ê²½í—˜ì´ ìˆì–´ì„œ í‹€ë ¤ë„ ì¢‹ìœ¼ë‹ˆê¹Œ ìµœëŒ€í•œ êµ¬í˜„í•´ë³´ë„ë¡ ë…¸ë ¥í–ˆìœ¼ë‚˜ ì˜ ë˜ì§€ ì•Šì•˜ë‹¤..

- ì˜ëª»ëœ í’€ì´

```
def get_parent(c):
    global node
    if node[c] == c:
        return c
    return get_parent(node[c])

def union_find(node1,node2,cost):
    p_node1 = get_parent(node1)
    p_node2 = get_parent(node2)
    # ì´ë¯¸ ì—°ê²°ë˜ì–´ ìˆëŠ” ê²½ìš°
    if p_node1 == p_node2:
        return 0
    else:
        if p_node1 < p_node2:
            node[node2] = p_node1
        else:
            node[node1] = p_node2
        return cost
    
def solution(n, costs):
    global node
    node = [ i for i in range(n)]
    result = 0
    costs.sort(key = lambda x: x[2] )
    
    for c in costs:
        node1,node2,cost = c
        
        result += union_find(node1,node2,cost)
    return result
```

### í‹€ë¦°ì´ìœ 
 
 union_findë¥¼ í•´ì¤„ë•Œ í•´ë‹¹ ê·¸ë£¹ì— ì†í•œ ë…¸ë“œì˜ ëŒ€í‘œì¸ ë¶€ëª¨ë…¸ë“œë¥¼ ê°±ì‹ í•´ì¤˜ì•¼ í•˜ëŠ”ë° ìœ„ì˜ ì½”ë“œì—ì„œëŠ” ìê¸° ìì‹ ì„ ê°±ì‹ í•´ì¤˜ì„œ ë¬¸ì œê°€ ìˆì—ˆë‹¤.
 
 [0,0,2,2,2,2,2,2] ì¼ë•Œ ë§Œì•½ 1ë²ˆ ë…¸ë“œì™€ 4ë²ˆ ë…¸ë“œë¥¼ ì—°ê²°ì‹œì¼œì£¼ë©´ 4ë²ˆë…¸ë“œì˜ ë¶€ëª¨ë…¸ë“œì¸ 2ë²ˆë…¸ë“œì˜ ê°’ì„ ë°”ê¿”ì¤˜ì•¼ í•œë‹¤. => [0,0,0,2,2,2,2,2] 
 
 ê·¸ëŸ¬ë‚˜ ìœ„ì˜ ì½”ë“œì—ì„œëŠ” ìê¸° ìì‹ ì„ ë°”ê¿”ì¤˜ì„œ ê°™ì€ ê·¸ë£¹ë‚´ì˜ ë‹¤ë¥¸ ë…¸ë“œë“¤ì€ ë¶€ëª¨ë…¸ë“œê°€ ë°”ë€ì¤„ ëª¨ë¥¸ë‹¤. => [0,0,2,2,0,2,2,2] (ì˜ëª»ëœ ë…¸ë“œ)
 
 ### ì˜¬ë°”ë¥¸ í’€ì´
 
 ```
 import heapq # ë‹¤ì‹œí’€ê¸°
def get_parent(c, node):
    if c[node] == node:
        return node
    return get_parent(c, c[node])

def union_find(c, edge):
    p1 = get_parent(c, edge[1])
    p2 = get_parent(c, edge[2])
    
    if not p1 == p2:
        if p1 > p2:
            c[p1] = p2
        else:
            c[p2] = p1
        return edge[0]
    return 0
    
def solution(n, costs):
    
    answer = 0
    h = [(cost,node1,node2) for node1, node2, cost in costs]
    heapq.heapify(h)
    
    c = [ x for x in range(n) ]
    
    while h:
        answer += union_find(c, heapq.heappop(h) )
    return answer
```

- ë…¸ë“œë¥¼ ê°±ì‹ ì‹œì¼œì¤„ ë•Œ ë¶€ëª¨ë…¸ë“œë¥¼ ê°±ì‹ ì‹œì¼œ ì¤€ë‹¤!!
