
# 📚 표 병합

## 📌 [문제링크](https://school.programmers.co.kr/learn/courses/30/lessons/150366)

### 문제 해설

- 표 편집 프로그램을 작성하려고 한다.
- UPDATE r c value
    - (r,c)위치의 셀을 선택한다.
    - 선택한 셀의 값을 value로 바꾼다.
- UPDATE value value1 value2
    - value1을 값으로 가지고 있는 모든 셀을 선택한다.
    - 선택한 셀의 값을 value2로 바꾼다.
- Merge r1 c1 r2 c2
    - (r1,c1)위치의 셀과 (r2,c2)위치의 셀을 선택해서 병합
    - 위치가 같을 경우 무시
    - 두 셀 중 한 셀이 값을 가지고 있을 경우 병합된 셀은 그 값을 가지게 된다.
    - 두 셀 모두 값을 가지고 있을 경우 병합된 셀은 (r1,c1)위치의 셀 값을 가진다.
    - (r1,c1)와 (r2,c2)중 어느 위치를 선택해도 병합된 셀로 접근 
- UNMERGE r c
    - (r,c)위치의 셀을 선택하여 해당 셀의 모든 병합을 해제
    - 선택한 셀이 포함하고 있던 모든 셀은 프로그램 실행 초기의 상태로 돌아간다
    - 병합 해제 전 셀이 값을 가지고 있었을 경우 (r,c)위치의 셀이 그 값을 가진다.
- PRINT r c
    - (r,c)위치의 셀을 선택하여 셀의 값을 출력한다.
    - 선택한 셀이 비어있을 경우 "EMPTY"를 출력한다.

### 문제 풀이

- 유니온 파인드

```
def solution(commands):
    c_list = [ [ (i,j) for j in range(51)]  for i in range(51)]
    def get_parent(r,c):
        if (r,c) == c_list[r][c]:
            return (r,c)
        return get_parent(*c_list[r][c])
    
    def get_value(r,c):
        n_r,n_c = get_parent[r][c] 
        return sell[n_r][n_c]
    def unmerge(r,c):
        # r,c에 귀속된 자식노드들 초기화
        root = get_parent(r,c)
        mrg = [ (i,j) for i in range(51) for j in range(51) if get_parent(i,j) == root ]
        v = sell[root[0]][root[1]]
        '''
        for i in range(1,51):
            for j in range(1,51):
                if (i,j) == (r,c):
                    continue
                if get_parent(i,j) == (r,c):
                    c_list[i][j] = (i,j)
                    #unmerge(i,j)
        '''
        for rt in mrg:
            r1,c1 = rt
            c_list[r1][c1] = (r1,c1)
            sell[r1][c1] = "EMPTY"
        sell[r][c] = v
    
    sell = [ ["EMPTY"] * 51 for _ in range(51)]
    result = []
    for c in commands:
        command,items = c.split()[0],c.split()[1:]
        
        if command == 'UPDATE':
            # UPDATE r c value
            if len(items) > 2:
                r,c = get_parent(int(items[0]), int(items[1]))
                sell[r][c] = items[2]
            # UPDATE value1 value2
            else:
                value1 = items[0]
                value2 = items[1]
                for i in range(1,51):
                    for j in range(1,51):
                        r,c = get_parent(i,j)
                        sell[r][c] = value2 if sell[r][c] == value1 else sell[r][c]
            
        elif command == 'MERGE':
            r1,c1,r2,c2 = map(int,items)
            r1_p,c1_p = get_parent(r1,c1)
            r2_p,c2_p = get_parent(r2,c2)
            
            if r1_p == r2_p and c1_p == c2_p: continue
            
            c_list[r2_p][c2_p] = (r1_p,c1_p)
            v = sell[r1_p][c1_p] if sell[r1_p][c1_p] != 'EMPTY' else sell[r2_p][c2_p] 
            sell[r2_p][c2_p] = 'EMPTY'
            sell[r1_p][c1_p] = v
            #sell[r2_p][c2_p] = "EMPTY"
            #sell[r1_p][c1_p] = sell[r1_p][c1_p] if sell[r1_p][c1_p] != "EMPTY" else sell[r2_p][c2_p]
            #c_list[r2_p][c2_p] = (r1_p,c1_p)
            
        elif command == 'UNMERGE':
            r,c = map(int,items)
            #r_p,c_p = get_parent(r,c)
            #if (r,c) != (r_p,c_p):
            #    sell[r][c] = sell[r_p][c_p]
            #    sell[r_p][c_p] = "EMPTY"
            unmerge(r,c)
        else:
            r,c = map(int,items)
            r,c = get_parent(r,c)
            result.append(sell[r][c])    
            
    return result
```
