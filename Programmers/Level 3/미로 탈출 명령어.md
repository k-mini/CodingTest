
# ğŸ“š ë¯¸ë¡œ íƒˆì¶œ ëª…ë ¹ì–´

## ğŸ“Œ [ë¬¸ì œë§í¬](https://school.programmers.co.kr/learn/courses/30/lessons/150365)

### ë¬¸ì œ í•´ì„¤

- n * m í¬ê¸°ì˜ ê²©ìë¯¸ë¡œê°€ ì£¼ì–´ì§„ë‹¤. ë‚˜ëŠ” (x,y)ì˜ ì¢Œí‘œì—ì„œ ì‹œì‘í•´ (r,c)ê¹Œì§€ ì´ë™í•´ì„œ íƒˆì¶œí•´ì•¼ í•œë‹¤.
- ë¯¸ë¡œë¥¼ ì›€ì§ì¼ ìˆ˜ ìˆëŠ” ë²”ìœ„ëŠ” 1<= x <= n ê³¼ 1<= y <= m ì´ë©° ê°™ì€ ì¢Œí‘œì— ì—¬ëŸ¬ë²ˆ ë°©ë¬¸ ê°€ëŠ¥í•˜ë‹¤.
- (x,y)ì—ì„œ (r,c)ê¹Œì§€ ì´ë™í•˜ëŠ” ê±°ë¦¬ëŠ” kì—¬ì•¼ í•œë‹¤.
- íƒˆì¶œí•œ ê²½ë¡œë¥¼ ë¬¸ìì—´ë¡œ ë‚˜íƒ€ëƒˆì„ë•Œ, ë¬¸ìì—´ì´ ì‚¬ì „ ìˆœìœ¼ë¡œ ê°€ì¥ ë¹ ë¥¸ ê²½ë¡œë¡œ íƒˆì¶œí•´ì•¼ í•œë‹¤. ì´ë•Œ ê²½ë¡œë¥¼ return í•˜ëŠ” ë¬¸ì œì´ë‹¤.
- ë¶ˆê°€ëŠ¥í•˜ë©´ "impossible"ì„ return

### ë¬¸ì œ í’€ì´

- ì¤‘ë³µ ì²´í¬ë¥¼ ë°©ë¬¸ê²©ì ê¸°ì¤€ì´ ì•„ë‹ˆë¼ ë¬¸ìì—´ê³¼ ì¢Œí‘œë¡œ ì²´í¬ë¥¼ í•˜ë©´ ë¬¸ì œí•´ê²°ì´ ë˜ê² ë‹¤ ì‹¶ì–´ì„œ ì§‘í•©ìœ¼ë¡œ bfsí’€ì´ë¥¼ ì§„í–‰í•˜ì˜€ë‹¤.

- íë¥¼ ì´ìš©í•œ bfs í’€ì´ (ì‹œê°„ì´ˆê³¼)

```
from collections import deque
def solution(n, m, x, y, r, c, k):
    answer = 'z'
    v_set = set()
    move_dict = { 'l':[0,-1], 'r':[0,1], 'u':[-1,0], 'd':[1,0] }
    q = deque()
    #maps = [ for j in range(m) for i in range(n) ]
    q.append( ('',(x-1,y-1)) )
    
    while q:
        commands,coords = q.popleft()
        x,y = coords[0],coords[1]
        if len(commands) > k or answer == min(answer,commands):
            continue
        
        if x == r-1 and y == c-1 and len(commands) == k:
            answer = min(answer,commands)
            continue
        
        for key in move_dict.keys() :
            nx = x + move_dict[key][0]
            ny = y + move_dict[key][1]
            
            if  0 <= nx < n and 0<= ny < m and not (commands+key,nx,ny) in v_set :
                v_set.add( (commands+key,nx,ny) ) 
                q.append( (commands + key ,(nx,ny)) )
            
    #answer = sorted(set(answer))
    print(answer)
    return answer if answer != 'z' else 'impossible'
```

- ëª¨ë“  ê²½ë¡œë¥¼ íƒìƒ‰í•˜ë‹ˆ ì‹œê°„ì´ˆê³¼ê°€ ë– ì„œ êµ¬ê¸€ë§ì„ í†µí•´ ì°¾ì•„ë³´ë‹ˆ, ë¬¸ìì—´ì„ ì‚¬ì „ìˆœìœ¼ë¡œ dfs íƒìƒ‰í•´ì„œ í‘¸ëŠ” í’€ì´ë¥¼ ë°œê²¬í–ˆë‹¤.

- ìŠ¤íƒì„ ì´ìš©í•œ dfs í’€ì´ (êµ¬ê¸€ë§)
- dfsíƒìƒ‰ ì¤‘ ë‹¤ìŒê³¼ ê°™ì€ ì¡°ê±´ ì‹œ ë” ì´ìƒ íƒìƒ‰í•˜ì§€ ì•ŠëŠ”ë‹¤.
1. kê°€ ìµœì†Œ ì´ë™ ê±°ë¦¬ë³´ë‹¤ ì‘ìœ¼ë©´ ë„ë‹¬í•  ìˆ˜ ì—†ìœ¼ë¯€ë¡œ ë¶ˆê°€ëŠ¥
2. ì „ì²´ ì´ë™ ê±°ë¦¬ - ìµœì†Œ ì´ë™ ê±°ë¦¬ ì¦‰, ë‚¨ì€ ì´ë™ê±°ë¦¬ê°€ í™€ìˆ˜ë©´ ë¶ˆê°€ëŠ¥

- 2ë²ˆ ì¡°ê±´ì´ ì¢€ í—·ê°ˆë¦°ë‹¤. ìƒê°í•´ë³´ë©´ íŠ¹ì • ìœ„ì¹˜ì— ë„ë‹¬í•˜ë ¤ë©´ ê²°êµ­ ë§ˆì§€ë§‰ì—ëŠ” ì´í•©ì´ ìµœì†Œì´ë™ê±°ë¦¬ë§Œí¼ë§Œ ì´ë™í•´ì•¼ í•œë‹¤.  
ì˜ˆë¥¼ ë“¤ì–´, í…ŒìŠ¤íŠ¸ì¼€ì´ìŠ¤ 1ì—ì„œ (2,3) -> (3,1) ì„ ì´ë™í•  ë•Œ ê°ê° ì¢Œí‘œë¥¼ ë–¼ì–´ë†“ê³  ìƒê°í•´ë³´ë©´  ì•„ë˜ë¡œ 1ì¹¸ ì™¼ìª½ìœ¼ë¡œ 2ì¹¸ì´ë‹¤.  
ê²½ë¡œë¥¼ ë¶€í’€ë ¤ë„ ê²°êµ­ì—” (ìœ„ì•„ë˜ ì´ë™ì¹¸ìˆ˜ì˜ ì´í•©) => ì•„ë˜ 1 , (ì¢Œìš° ì´ë™ì¹¸ìˆ˜ì˜ ì´í•©) => 2ê°€ ë˜ì–´ì•¼ í•œë‹¤.  
ì˜ ìƒê°í•´ë³´ì.

- ìœ„ì•„ë˜ ì´ë™ ì¹¸ìˆ˜ëŠ” ê²°êµ­ 1(ë§ˆì§€ë§‰ìœ¼ë¡œ ë‚¨ì„ ìˆ˜) + (1 + (-1)) * n ì´ê³   
ì¢Œìš° ì´ë™ ì¹¸ìˆ˜ëŠ” ê²°êµ­ 2(ë§ˆì§€ë§‰ìœ¼ë¡œ ì´ë™í•  ìˆ˜) + (1 + (-1)) * m ì´ë‹¤.  
ìµœì†Œì´ë™ê±°ë¦¬ëŠ” í™€ or ì§  + ì§ìˆ˜ì¹¸ì´ë™ => í™€ or ì§ ì´ë¯€ë¡œ ê²°êµ­ í•´ë‹¹ ìœ„ì¹˜ì— ë„ë‹¬í•˜ë ¤ë©´ ìµœì†Œì´ë™ê±°ë¦¬ì˜ í™€ì§ê³¼ ê°™ì•„ì•¼ í•œë‹¤. 

```
def solution(n, m, x, y, r, c, k):
    # d > l > r > u
    stack = [(x,y,[])]
    result = 'impossible'
    while stack:
        x_pos, y_pos, path = stack.pop()
        if len(path) == k and (x_pos, y_pos) == (r, c):
            result = ''.join(path)
            break
        remain, shortest_path = k - len(path), abs(x_pos - r) + abs(y_pos - c)
        # ë‚¨ì€ê±°ë¦¬(remain)ê°€ ìµœë‹¨ê²½ë¡œë³´ë‹¤ ì»¤ì•¼ ì´ë™ ê°€ëŠ¥.
        # ë˜í•œ í¬ë‹¤í•´ë„ ëª©í‘œì ì— ë„ë‹¬ ê°€ëŠ¥í•œ ê²½ë¡œëŠ” ìµœë‹¨ê²½ë¡œë¶€í„° ì§ìˆ˜ì¦ê°€ì´ê¸° ë•Œë¬¸ì— remainì˜ í™€ì§ê³¼ ìµœë‹¨ ê²½ë¡œì˜ í™€ì§ì´ ê°™ì•„ì•¼í•¨
        if remain < shortest_path or remain % 2 != shortest_path % 2:    
            continue
        if x_pos > 1:
            stack.append((x_pos - 1, y_pos, path + ['u'] ))
        if y_pos < m:
            stack.append((x_pos, y_pos + 1, path + ['r'] ))
        if y_pos > 1:
            stack.append((x_pos, y_pos - 1, path + ['l'] ))
        if x_pos < n:
            stack.append((x_pos + 1, y_pos, path +['d'] ))
            
    return result
```

- ë”•ì…”ë„ˆë¦¬ë¥¼ ì´ìš©í•œ bfs í’€ì´ ì‹œë„ (ì‹¤íŒ¨)
- ë”•ì…”ë„ˆë¦¬ì— ì¢Œí‘œë³„ë¡œ ì‚¬ì „ìˆœì„ ë¹„êµí•´ ì œì¼ ë¹ ë¥¸ ì‚¬ì „ìˆœë§Œ ì €ì¥í•˜ë ¤ í–ˆìœ¼ë‚˜.. ì§§ì€ ë¬¸ìì—´ì´ ë”•ì…”ë„ˆë¦¬ìƒìœ¼ë¡œ ì•ì´ë¼ ì‹¤íŒ¨  
ex) 'dllrl'ì„ ë½‘ì•„ì•¼í•˜ëŠ”ë° ëª©ì ì§€ì— ë„ì°©í•´ì„œ 'dll' ì—ì„œ ì˜¤ë¥¸ìª½ìœ¼ë¡œ ì´ë™í•˜ë ¤í–ˆìœ¼ë‚˜ ì´ë¯¸ ì˜¤ë¥¸ìª½ì—ëŠ” 'dl'ì´ ìˆë‹¤.  
'dll'ì€ 'dl'ê³¼ë¹„êµí•´ì„œ ì‚¬ì „ìˆœìœ¼ë¡œ ë’¤ì— ìˆê¸° ë–„ë¬¸ì— ì‹¤íŒ¨

```
from collections import deque
from collections import defaultdict
def solution(n, m, x, y, r, c, k):
    
    answer = 'z'
    move_dict = { 'l':[0,-1], 'r':[0,1], 'u':[-1,0], 'd':[1,0] }
    v_dict = defaultdict(lambda : 'z')
    v_dict[(x,y)] = ''
    q = deque()
    #maps = [ for j in range(m) for i in range(n) ]
    q.append( ('',(x,y)) )
    
    while q:
        commands,coords = q.popleft()
        x,y = coords[0],coords[1]
        if (x,y) == (3,1) : print(x,y)
        if len(commands) > k or v_dict[(x,y)] < commands :
            #print('test1')
            continue
        
        if x == r and y == c and len(commands) == k:
            #answer = min(answer,commands)
            continue
        
        for key in move_dict.keys() :
            nx = x + move_dict[key][0]
            ny = y + move_dict[key][1]
            if (x,y) == (3,1) : print(nx,ny,commands+key,v_dict[(nx,ny)])
            if  1 <= nx <= n and 1<= ny <= m and commands + key < v_dict[(nx,ny)] or  :
                #print(nx,ny,commands+key)
                #print(nx,ny,v_dict[(nx,ny)],commands+key)
                v_dict[(nx,ny)] = commands + key
                q.append( (commands + key ,(nx,ny)) )
            
    #answer = sorted(set(answer))
    print(v_dict[(r,c)])
    return answer if answer != 'z' else 'impossible'
```


