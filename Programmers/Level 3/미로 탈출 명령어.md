
# ğŸ“š ë¯¸ë¡œ íƒˆì¶œ ëª…ë ¹ì–´

## ğŸ“Œ [ë¬¸ì œë§í¬](https://school.programmers.co.kr/learn/courses/30/lessons/150365)

### ë¬¸ì œ í•´ì„¤

- n * m í¬ê¸°ì˜ ê²©ìë¯¸ë¡œê°€ ì£¼ì–´ì§„ë‹¤. ë‚˜ëŠ” (x,y)ì˜ ì¢Œí‘œì—ì„œ ì‹œì‘í•´ (r,c)ê¹Œì§€ ì´ë™í•´ì„œ íƒˆì¶œí•´ì•¼ í•œë‹¤.
- ë¯¸ë¡œë¥¼ ì›€ì§ì¼ ìˆ˜ ìˆëŠ” ë²”ìœ„ëŠ” 1<= x <= n ê³¼ 1<= y <= m ì´ë©° ê°™ì€ ì¢Œí‘œì— ì—¬ëŸ¬ë²ˆ ë°©ë¬¸ ê°€ëŠ¥í•˜ë‹¤.
- (x,y)ì—ì„œ (r,c)ê¹Œì§€ ì´ë™í•˜ëŠ” ê±°ë¦¬ëŠ” kì—¬ì•¼ í•œë‹¤.
- íƒˆì¶œí•œ ê²½ë¡œë¥¼ ë¬¸ìì—´ë¡œ ë‚˜íƒ€ëƒˆì„ë•Œ, ë¬¸ìì—´ì´ ì‚¬ì „ ìˆœìœ¼ë¡œ ê°€ì¥ ë¹ ë¥¸ ê²½ë¡œë¡œ íƒˆì¶œí•´ì•¼ í•œë‹¤. ì´ë•Œ ê²½ë¡œë¥¼ return í•˜ëŠ” ë¬¸ì œì´ë‹¤.
- ë¶ˆê°€ëŠ¥í•˜ë©´ "impossible"ì„ return

### ë¬¸ì œ í’€ì´

- ì¤‘ë³µ ì²´í¬ë¥¼ ë°©ë¬¸ê²©ì ê¸°ì¤€ì´ ì•„ë‹ˆë¼ ë¬¸ìì—´ê³¼ ì¢Œí‘œë¡œ ì²´í¬ë¥¼ í•˜ë©´ ë¬¸ì œí•´ê²°ì´ ë˜ê² ë‹¤ ì‹¶ì–´ì„œ ì§‘í•©ìœ¼ë¡œ bfsí’€ì´ë¥¼ ì§„í–‰í•˜ì˜€ë‹¤.

- íë¥¼ ì´ìš©í•œ bfs í’€ì´ (ì‹œê°„ì´ˆê³¼)

```
from collections import deque
def solution(n, m, x, y, r, c, k):
    answer = 'z'
    v_set = set()
    move_dict = { 'l':[0,-1], 'r':[0,1], 'u':[-1,0], 'd':[1,0] }
    q = deque()
    #maps = [ for j in range(m) for i in range(n) ]
    q.append( ('',(x-1,y-1)) )
    
    while q:
        commands,coords = q.popleft()
        x,y = coords[0],coords[1]
        if len(commands) > k or answer == min(answer,commands):
            continue
        
        if x == r-1 and y == c-1 and len(commands) == k:
            answer = min(answer,commands)
            continue
        
        for key in move_dict.keys() :
            nx = x + move_dict[key][0]
            ny = y + move_dict[key][1]
            
            if  0 <= nx < n and 0<= ny < m and not (commands+key,nx,ny) in v_set :
                v_set.add( (commands+key,nx,ny) ) 
                q.append( (commands + key ,(nx,ny)) )
            
    #answer = sorted(set(answer))
    print(answer)
    return answer if answer != 'z' else 'impossible'
```

- ëª¨ë“  ê²½ë¡œë¥¼ íƒìƒ‰í•˜ë‹ˆ ì‹œê°„ì´ˆê³¼ê°€ ë– ì„œ êµ¬ê¸€ë§ì„ í†µí•´ ì°¾ì•„ë³´ë‹ˆ, ë¬¸ìì—´ì„ ì‚¬ì „ìˆœìœ¼ë¡œ dfs íƒìƒ‰í•´ì„œ í‘¸ëŠ” í’€ì´ë¥¼ ë°œê²¬í–ˆë‹¤.

- ìŠ¤íƒì„ ì´ìš©í•œ dfs í’€ì´ (êµ¬ê¸€ë§)

```
def solution(n, m, x, y, r, c, k):
    # d > l > r > u
    stack = [(x,y,[])]
    result = 'impossible'
    while stack:
        x_pos, y_pos, path = stack.pop()
        if len(path) == k and (x_pos, y_pos) == (r, c):
            result = ''.join(path)
            break
        remain, shortest_path = k - len(path), abs(x_pos - r) + abs(y_pos - c)
        # ë‚¨ì€ê±°ë¦¬(remain)ê°€ ìµœë‹¨ê²½ë¡œë³´ë‹¤ ì»¤ì•¼ ì´ë™ ê°€ëŠ¥.
        # ë˜í•œ í¬ë‹¤í•´ë„ ëª©í‘œì ì— ë„ë‹¬ ê°€ëŠ¥í•œ ê²½ë¡œëŠ” ìµœë‹¨ê²½ë¡œë¶€í„° ì§ìˆ˜ì¦ê°€ì´ê¸° ë•Œë¬¸ì— remainì˜ í™€ì§ê³¼ ìµœë‹¨ ê²½ë¡œì˜ í™€ì§ì´ ê°™ì•„ì•¼í•¨
        if remain < shortest_path or remain % 2 != shortest_path % 2:    
            continue
        if x_pos > 1:
            stack.append((x_pos - 1, y_pos, path + ['u'] ))
        if y_pos < m:
            stack.append((x_pos, y_pos + 1, path + ['r'] ))
        if y_pos > 1:
            stack.append((x_pos, y_pos - 1, path + ['l'] ))
        if x_pos < n:
            stack.append((x_pos + 1, y_pos, path +['d'] ))
            
    return result
```
