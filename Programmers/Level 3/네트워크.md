
# ğŸ“š ë„¤íŠ¸ì›Œí¬

## ğŸ“Œ [ë¬¸ì œë§í¬](https://school.programmers.co.kr/learn/courses/30/lessons/43162)

### ë¬¸ì œí•´ì„¤

- ê° ë…¸ë“œë§ˆë‹¤ ê²½ë¡œì •ë³´ê°€ ì£¼ì–´ì ¸ìˆë‹¤. computers[i][j]ê°€ 1ì´ë©´ ië…¸ë“œì™€ jë…¸ë“œëŠ” ì´ì–´ì ¸ ìˆë‹¤. 0ì´ë©´ ì—°ê²°ì´ ëŠì–´ì ¸ ìˆë‹¤.
- ì´ ë•Œì˜ ë„¤íŠ¸ì›Œí¬ì˜ ê°œìˆ˜ë¥¼ êµ¬í•˜ëŠ” ë¬¸ì œì´ë‹¤.

### ë¬¸ì œí’€ì´

- ìœ ë‹ˆì˜¨íŒŒì¸ë“œ
- ë¶€ëª¨ë…¸ë“œë¼ë¦¬ ë¹„êµí•´ì•¼ í•˜ëŠ”ë° ìê¾¸ ë¶€ëª¨ë…¸ë“œê°€ ì•„ë‹Œ ë„¤íŠ¸ì›Œí¬ê°€ ì†í•˜ëŠ”ì§€ í™•ì¸í•˜ëŠ” ë…¸ë“œë¡œ ë¹„êµí•´ì„œ ì˜¤ë¥˜ê°€ ë‚¬ë‹¤.

```
def get_parent(c,node):
    if c[node] == node:
        return node
    return get_parent(c,c[node])

def solution(n, graphs):
    c = [ i for i in range(n) ]
    
    for i,graph in enumerate(graphs):
        for j,connection in enumerate(graph):
            if i == j : continue
            if connection == 1:
                p1 = get_parent(c,i)
                p2 = get_parent(c,j)
                if p1 < p2 :
                    c[p2] = p1
                else:
                    c[p1] = p2 
        #print(c)
    
    n_set = set()
    for i in range(n):
        n_set.add(get_parent(c,i))
    #print(n_set)
    #print(c)
    return len(n_set)
```

- bfs íƒìƒ‰

```
from collections import deque
def solution(n, computers):
    
    answer = 0
    graph = {}
    for start in range(n):
        graph[start] = []
        for end,edge in enumerate(computers[start]):
            if edge == 1 and start != end:
                graph[start].append(end)
    visited =[]
    not_visited = list(graph.keys())
    while not_visited :
        visited += bfs(graph, not_visited[0] )
        #not_visited = list(set(graph.keys()) - set(visited))
        not_visited = list( set(not_visited) - set(visited) )
        answer += 1
    return answer
    
def bfs(graph , root):
    visited = []
    q = deque([root])
    while q:
        now = q.popleft()
        #if now not in visited:
        visited.append(now)
        q += list( set(graph[now]) - set(visited)) # í˜„ì¬ë…¸ë“œì—ì„œ ë°©ë¬¸í•˜ì§€ ì•Šì€ê³³ íƒìƒ‰
    return visited
```

- bfs íƒìƒ‰ ì¬í’€ì´

```
from collections import deque
def solution(n, computers):

    answer= 0
    graph = {}
    for i,com in enumerate(computers):
        graph[i] = []
        for node,connected in enumerate(com):
            if i != node and connected==1:
                graph[i].append(node)
    #print(graph)
    q= deque()
    visited = [ False for _ in range(n) ]
    for i in range(n):
        if not visited[i]:
            visited[i] = True
            q.append(i)
            answer +=1
            while q:
                node = q.popleft()
                
                for nxt_node in graph[node]:
                    if not visited[nxt_node]:
                        visited[nxt_node] = True
                        q.append(nxt_node)
    
    return answer
```

- ìœ ë‹ˆì˜¨ íŒŒì¸ë“œ ì¬í’€ì´

```
from collections import deque
def get_parent(c,node):
    if c[node] == node:
        return node
    return get_parent( c, c[node] )

def solution(n, computers):
    
    c = [ x for x in range(n) ]
    network = [0] # ë„¤íŠ¸ì›Œí¬ë‹¹ ê°€ì¥ ì‘ì€ ë…¸ë“œ ì €ì¥
    # ë¶€ëª¨ë…¸ë“œ ì •ë³´ ìµœì‹ í™” 
    for i in range(n) : # iì˜ ë¶€ëª¨ë…¸ë“œ ì°¾ê¸°
        for j in range(i+1,n):
            p1 = get_parent(c, i)
            p2 = get_parent(c, j)
            if p1==p2 or not computers[i][j]: continue # ì´ë¯¸ ìœ ë‹ˆì˜¨ íŒŒì¸ë“œ ë˜ìˆê±°ë‚˜ ì—°ê²°ë˜ì§€ì•Šìœ¼ë©´ ìŠ¤í‚µ
            # ì œì¼ ë¨¼ì € ì—°ê²° ë˜ì–´ìˆëŠ” ë…¸ë“œì˜ ë¶€ëª¨ë…¸ë“œ ë”°ë¼ê°€ê¸°
            if p1 < p2:
                c[p2] = p1
            elif p1 > p2:
                c[p1] = p2
    
    # 1ë²ˆ ì»´í“¨í„°ëŠ” ë¬´ì¡°ê±´ ì‡ìœ¼ë¯€ë¡œ ìµœì†Œ í•œê°œì˜ ë„¤íŠ¸ì›Œí¬ë¥¼ ê°€ì§
    for i in range(1,n):
        if not get_parent(c,i) in network: # ië²ˆ ì»´í“¨í„°ê°€ ì†í•´ìˆëŠ” ë„¤íŠ¸ì›Œí¬ê°€ ì—†ë‹¤ë©´ ì¶”ê°€
            network.append(c[i])
    return len(network)
```
