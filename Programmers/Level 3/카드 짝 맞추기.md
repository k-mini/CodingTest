
# ğŸ“š ì¹´ë“œ ì§ ë§ì¶”ê¸°

## ğŸ“Œ [ë¬¸ì œë§í¬](https://school.programmers.co.kr/learn/courses/30/lessons/72415)

### ë¬¸ì œ í•´ì„¤

- ì¹´ë“œ ë’¤ì§‘ê¸° ë¬¸ì œì´ë‹¤.
- ë‚´ê°€ í•  ìˆ˜ ìˆëŠ” í–‰ë™ì€ 1ì¹¸ì´ë™, Ctrl ì´ë™, ë’¤ì§‘ê¸° 3ê°€ì§€ë¡œ êµ¬ë¶„í•  ìˆ˜ ìˆë‹¤. (ê° í–‰ë™ì€ 1ë²ˆì˜ ë™ì‘ìœ¼ë¡œ ìˆ˜í–‰í•  ìˆ˜ ìˆë‹¤.)
- ë§Œì•½ ê°™ì€ ì¹´ë“œë¥¼ ë’¤ì§‘ìœ¼ë©´ ë‘ ì¹´ë“œëŠ” í™”ë©´ì—ì„œ ì‚¬ë¼ì§€ê²Œ ëœë‹¤. ëª¨ë“  ì¹´ë“œë¥¼ í™”ë©´ì—ì„œ ì œê±°í•´ì•¼ í• ë•Œ í‚¤ ì¡°ì‘ íšŸìˆ˜ì˜ ìµœì†Œë™ì‘ìˆ˜ë¥¼ êµ¬í•˜ëŠ” ë¬¸ì œì´ë‹¤.


### ë¬¸ì œ í’€ì´

- boardë¥¼ ê·¸ëŒ€ë¡œ ì“°ë©´ bfs íƒìƒ‰í•  ë•Œ ì£¼ì†Œê°’ì„ ê³µìœ í•˜ë¯€ë¡œ ê°’ì„ ë…ë¦½ì ìœ¼ë¡œ êµ¬ë¶„í•  ìˆ˜ ì—†ìœ¼ë¯€ë¡œ copyë¥¼ í•´ì¤˜ì•¼ í•œë‹¤. ì´ëŠ” ë²ˆê±°ë¡­ê¸° ë•Œë¬¸ì— ê·¸ëƒ¥ ë¬¸ìì—´ ì²˜ë¦¬í•œë‹¤. 
- bfs íƒìƒ‰ì´ë¯€ë¡œ cntëŠ” ìˆœì„œëŒ€ë¡œ ì¦ê°€í•œë‹¤. ì¦‰, ì‹œê°„ìˆœìœ¼ë¡œ íƒìƒ‰í•œë‹¤ëŠ” ëœ»ì´ë‹¤.
- visitì— cntë¥¼ ì•ˆë„£ëŠ” ì´ìœ ëŠ” ì´í›„ì— ë“¤ì–´ì˜¨ ê°™ì€ ë…¸ë“œë¥¼ íƒìƒ‰í•˜ì§€ ì•Šê¸° ìœ„í•´ì„œ ì´ë‹¤. ë§Œì•½ cntë¥¼ ë„£ìœ¼ë©´ ê°™ì€ ì‹œê°„ì— ê°™ì€ ì¡°ê±´ë§Œ êµ¬ë³„í•˜ë‚˜
cntë¥¼ ë„£ì§€ ì•Šìœ¼ë©´ ê·¸ ì´í›„ ì‹œê°„ëŒ€ì— ë“¤ì–´ì˜¨ ê°™ì€ ì¡°ê±´ì¸ ë…¸ë“œë¥¼ ëª¨ë‘ ì œì™¸í•˜ê¸° ë•Œë¬¸ì— cntë¥¼ ì œì™¸í•˜ê³  visitì— ë„£ëŠ”ë‹¤.
- ê°™ì€ ë…¸ë“œê°€ ì´ë¯¸ ë“¤ì–´ì™”ë‹¤ë©´ ì´ì „ ì‹œê°„ëŒ€ì— ë“¤ì–´ì™”ê¸° ë•Œë¬¸ì— í˜„ì¬ ë…¸ë“œë¡œ íƒìƒ‰í•´ë„ ì‹œê°„ë§Œ ëŠ˜ì–´ë‚œ ê°™ì€ bfs íƒìƒ‰ì„ í•œë‹¤.  
(ì—¬ëŸ¬ê°€ì§€ ê²½ìš°ë¥¼ ì§„í–‰í•˜ëŠ” ê²ƒì„ íŠ¸ë¦¬êµ¬ì¡°ë¡œ ìƒê°í•´ë³´ì. íŠ¸ë¦¬ì˜ ê¹Šì´ë¥¼ ì‹œê°„ì´ë¼ ìƒê°í•˜ë©´ ì´ë¯¸ ì´ì „ ì‹œê°„ì—ì„œ ë˜‘ê°™ì€ ê²½ìš°(ì„œë¸ŒíŠ¸ë¦¬)ë¥¼ ë§Œë“¤ë©´ì„œ ìµœë‹¨ ì‹œê°„ì„ ë§Œë“¤ ìˆ˜ ìˆë‹¤.  
ë”°ë¼ì„œ í˜„ì¬ ì‹œê°„ëŒ€ì—ì„œ ê°™ì€ ì¡°ê±´ìœ¼ë¡œ íƒìƒ‰ì„ ì§„í–‰í•˜ë©´ ì‹œê°„ë§Œ ëŠ˜ì–´ë‚  ë¿ ë¬´ì˜ë¯¸í•œ íƒìƒ‰ì„ ì§„í–‰í•œë‹¤.)

- ë‚´ê°€ ì°©ê°í•œ ê²ƒì€ ì´ê±°ë‹¤. ë§Œì•½ ë…¸ë“œ í•˜ë‚˜ëŠ” 1ì´ˆì— ë‹¤ë¥¸ ë…¸ë“œí•˜ë‚˜ëŠ” 3ì´ˆì— ê°™ì€ ìœ„ì¹˜ì— ë„ì°©í–ˆëŠ”ë°, 3ì´ˆì—ëŠ” ì¹´ë“œë¥¼ í•˜ë‚˜ ë’¤ì§‘ê³  ì˜¤ëŠë¼ ëŠ¦ìœ¼ë©´ ì–´ë–¡í•˜ì§€? ì´ëŸ° ìƒê°ì´ë‹¤.
ê·¸ë˜ì„œ ì‹œê°„ëŒ€ë³„ë¡œ ì¡°ê±´(ìƒí™©)ì„ êµ¬ë³„í•´ì£¼ê¸° ìœ„í•´ ë…¸ë“œë³„ë¡œ ë³´ë“œì˜ ìƒí™©ê³¼ í˜„ì¬ ì–´ë–¤ ì¹´ë“œë¥¼ ë’¤ì§‘ì—ˆëŠ”ì§€ ë…¸ë“œì— ì •ë³´ë¥¼ ë„£ì–´ì£¼ëŠ” ê²ƒì´ë‹¤.

- ì¹´ë“œë¥¼ ë’¤ì§‘ì„ì§€ ì§„í–‰í•  ë•Œ ë‘ê°€ì§€ ê²½ìš°ê°€ ìˆë‹¤.
    1. ì´ì „ì— ë’¤ì§‘ì€ ì¹´ë“œê°€ ìˆë‹¤. -> ì´ì „ì— ê°™ì€ ì¹´ë“œë¥¼ ë’¤ì§‘ì—ˆì„ë•Œë§Œ ë’¤ì§‘ëŠ” ê²½ìš°ë¥¼ ë§Œë“ ë‹¤. í˜„ì¬ ì„ íƒëœ ì¹´ë“œì™€ ì´ì „ì— ë’¤ì§‘ì€ ì¹´ë“œê°€ ë‹¤ë¥´ë©´ ë’¤ì§‘ì–´ë´¤ì ë™ì‘ìˆ˜ë§Œ ëŠ˜ì–´ë‚ ë¿ ë¬´ì˜ë¯¸í•œ íƒìƒ‰ì´ê¸° ë•Œë¬¸ì´ë‹¤.
    2. ì´ì „ì— ë’¤ì§‘ì€ ì¹´ë“œê°€ ì—†ë‹¤. -> ë’¤ì§‘ì€ ì¹´ë“œê°€ ì—†ìœ¼ë¯€ë¡œ ë’¤ì§‘ì–´ì£¼ëŠ” ì¹´ë“œë¥¼ í•˜ë‚˜ ë§Œë“ ë‹¤. -> ìµœì†Œ 2ê°œì˜ ì¹´ë“œë¥¼ ë’¤ì§‘ì–´ì•¼ í•˜ë¯€ë¡œ í˜„ì¬ ì¹´ë“œë¥¼ ë’¤ì§‘ëŠ” ê²½ìš°ë¥¼ ë§Œë“ ë‹¤.

í–‰ë™ì„ êµ¬ë¶„í•˜ìë©´ ë‹¤ìŒê³¼ ê°™ë‹¤.
- ì¹´ë“œë¥¼ ì•„ë¬´ê²ƒë„ ë’¤ì§‘ì§€ ì•Šì€ ìƒíƒœ
    - ì´ë™
    - ctrl ì´ë™
    - ë’¤ì§‘ê¸°(í˜„ì¬ ìœ„ì¹˜ì— ì¹´ë“œê°€ ì¡´ì¬í•  ë•Œ ì¡°ê±´ë¶€ë¡œ)
- ì¹´ë“œë¥¼ í•˜ë‚˜ ë’¤ì§‘ì€ ìƒíƒœ
    - ì´ë™
    - ctrl ì´ë™
    - ê°™ì€ ì¹´ë“œì¼ ë•Œë§Œ ë’¤ì§‘ê¸°
    - ~~ë‹¤ë¥¸ ì¹´ë“œì¼ë•Œ ë’¤ì§‘ê¸°~~ (ë¬´ì˜ë¯¸í•œ ë™ì‘ìˆ˜ ì¦ê°€ì´ë¯€ë¡œ íƒìƒ‰í•˜ì§€ ì•ŠìŒ)


```
from collections import deque

dy = [-1,1,0,0]
dx = [0,0,-1,1]

def solution(board,r,c):
    def isEnd(s:str) -> bool:
        for c in s:
            if c != '0':
                return False
        return True
    
    def OOB(y, x) -> bool :
        if (not 0 <= y < 4) or (not 0 <= x < 4):
            return True
        return False
    
    def isOnEdgeByDirection(y, x, d) -> bool:
        
        if d == 0:
            if y == 0 :
                return True
        elif d == 1:
            if y == 3:
                return True
        elif d == 2:
            if x == 0:
                return True
        elif d == 3:
            if x == 3:
                return True
        return False
    
    def serialize(board) -> str:
        ret = ''
        for r in board:
            for num in r:
                ret += str(num)
        
        return ret
    
    def switchTo0(s:str,num:str) -> int:
        return s.replace(num,'0')
    
    def idxConverter(y, x) -> int:
        return 4 * y + x
    
    visit = set()
    
    # ë³´ë“œì˜ ìƒíƒœ, ì»¤ì„œì˜ ìœ„ì¹˜, ì»¤ì„œê°€ ì¹´ë“œë¥¼ ë’¤ì§‘ì—ˆëŠ”ì§€, ë’¤ì§‘íŒ ì¹´ë“œ ìˆë‹¤ë©´ ê·¸ ìœ„ì¹˜
    visit.add(( serialize(board),(r,c), False,(-1,-1) ))
    q = deque()
    q.append((serialize(board),r,c,False,-1,-1,0) )
    
    while q:
        b, y, x, isFlipped, f_y, f_x, count = q.popleft()
        
        # ctrl ì´ë™
        for k in range(4):
            ny, nx = y + dy[k], x + dx[k]
            
            if OOB(ny,nx): # ë²”ìœ„ë¥¼ ë²—ì–´ë‚¬ëŠ”ì§€
                continue
            
            while b[idxConverter(ny,nx)] == '0' and not isOnEdgeByDirection(ny,nx,k):
            #while b[idxConverter(ny,nx)] != '0' or isOnEdgeByDirection(ny,nx,k):
                ny, nx = ny+ dy[k], nx+ dx[k]
                
            if (b, (ny, nx), isFlipped, (f_y, f_x)) in visit:
                continue
                
            visit.add((b, (ny, nx), isFlipped, (f_y, f_x)))
            q.append((b, ny, nx, isFlipped, f_y, f_x, count + 1))
            
        # ìƒí•˜ì¢Œìš° ë„¤ë°©í–¥ ì´ë™
        
        for k in range(4):
            ny, nx = y + dy[k] , x + dx[k]
            
            if OOB(ny,nx):
                continue
                
            if (b, (ny, nx), isFlipped, (f_y, f_x)) in visit:
                continue
                
            visit.add((b, (ny, nx), isFlipped, (f_y, f_x)))
            q.append((b, ny, nx, isFlipped, f_y, f_x, count + 1))
        
        # í˜„ì¬ í•œì¥ì€ ë’¤ì§‘ì€ ìƒíƒœì—ì„œ ë‹¤ë¥¸ê²ƒ ë’¤ì§‘ìœ¼ë¡œ í• ë•Œ
        if isFlipped:
            # ì¹´ë“œ ì§ ì°¾ëŠ”ë° ì„±ê³µ
            # 0ìœ¼ë¡œ ë’¤ì§‘ê¸°
            if b[idxConverter(f_y, f_x)] == b[idxConverter(y,x)] and (f_y,f_x) != (y,x):
            
                b = switchTo0(b, b[idxConverter(f_y, f_x)])
                
                # ì—¬ê¸°ì„œ í™•ì¸
                
                if isEnd(b):
                    return count + 1
                
                visit.add( (b, (y,x), False, (-1, -1)) )
                q.append((b, y, x, False, -1, -1, count + 1))
                
            # ì§ì´ ì•ˆë§ìŒ
            else:
                if (b, (y,x), False,(-1,-1)) in visit:
                    continue
                visit.add((b, (y,x), False, (-1, -1)))
                q.append((b, y, x, False, -1, -1, count + 1))
        #ì•„ì§ ë’¤ì§‘ì§€ ì•ŠìŒ
        #ì´ì œ ë’¤ì§‘ê¸°
        else:
            if (b, (y, x), True, (y, x)) in visit:
                continue
                
            visit.add((b, (y, x), True, (y, x)))
            q.append((b, y, x, True, y, x, count + 1))
```

- 2ì°¨ í’€ì´

```
from itertools import permutations
from collections import deque

def ctrl(board, x0, y0, dx, dy):
    for i in range(1,4):
        if 0<= (x1 := x0 + dx * i) < 4 and 0<= (y1 := y0 + dy * i) < 4:
            if board[x1][y1]> 0:
                return (x1,y1)
            l = i
    return (x0 + dx * l , y0 + dy * l)
        
def move(board, xy0, xy1):
    dist = [[6] * 4 for _ in range(4)]
    q = deque([(xy0, 0)])
    while q:
        [x, y], d = q.popleft()
        if d < dist[x][y]:
            dist[x][y] = d
            for dx, dy in [(1,0),(-1,0),(0,1),(0,-1)]:
                if 0<= x + dx < 4 and 0<= y+ dy < 4:
                    q.append(( (x + dx, y + dy ), d + 1 ))
                    q.append(( ctrl(board,x,y,dx,dy), d + 1 ))
                    
    return dist[xy1[0]][xy1[1]]

def solution(board,r,c):
    loc = {k: [] for k in range(1,7)}
    for i in range(4):
        for j in range(4):
            if board[i][j]:
                loc[board[i][j]].append((i,j))
                
    minv = 100
    for p in permutations(filter(lambda v: v, loc.values())):
        sumv = 0
        xys = [(r,c)]
        stage = [[v for v in w] for w in board]
        for xy1, xy2 in p:
            # vsëŠ” (xysì¢Œí‘œë“¤ -> xy1 or xy2 ê¹Œì§€ì˜ ì´ë™ê±°ë¦¬, ë§ˆì§€ë§‰ ì§€ì )ì˜ ìš”ì†Œë“¤ë¡œ ì´ë£¨ì–´ì ¸ ìˆë‹¤.
            vs = [(move(stage,xy,xy1) + move(stage, xy1,xy2), xy2) for xy in xys ] \
               + [(move(stage,xy,xy2) + move(stage, xy2,xy1), xy1) for xy in xys]
            stage[xy1[0]][xy1[1]] = stage[xy2[0]][xy2[1]] = 0
            sumv += (mvn := min(vs)[0]) + 2 # 2ëŠ” ì—”í„°2ë²ˆ
            xys = [xy for m, xy in vs if m == mvn ]
        minv = min(sumv,minv)
    return minv
```
