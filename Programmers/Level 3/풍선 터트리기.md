
# 📚 풍선 터트리기

## 📌 [문제링크](https://school.programmers.co.kr/learn/courses/30/lessons/68646)

### 문제 해설

- 풍선에는 각각의 숫자가 쓰여있고 임의의 인접한 두개의 풍선을 비교하여 하나만 터트릴 수 있는데, 이 때 숫자가 큰 풍선을 터트린다.
- 더 작은 풍선을 터트리는 행위는 최대 1번만 가능하다.
- 풍선들의 번호가 담긴 배열 a가 주어질 때 풍선을 1개만 남을 때까지 터트렸을 때 최후까지 남기는 것이 가능한 풍선들의 개수를 return하는 문제이다.

### 문제 풀이

- 제일 왼쪽,오른쪽에 있는 풍선은 무조건 터트릴 수 있다.(마지막에 제일 끝에있는 풍선과 끝에 인접한 풍선이 남는데, 이 때 끝에 있는 풍선의 숫자가 클 경우 더 작은 풍선을 터트리는 기회를 사용한다.)  
- 중간에 있는 풍선을 살리려고 할 때 [해당 풍선 왼쪽라인에 있는 최솟값, 살리려는 풍선, 해당 풍선 오른쪽에 있는 최솟값] 이 3개중에 가장 크면 마지막에 남길 수 없다.
- 1번 밖에 없는 작은 풍선을 터트리는 행위는 살리려는 풍선과 다른요소를 비교해서 살리려는 풍선이 더 클 때 사용하는 것이 좋다.
- 왼쪽 영역이나 오른쪽 영역을 정리할 때 써도 좋으나 만약 쓰게 되면 살리려는 풍선이 마지막에 남는 3개 중 무조건 작아야 살릴 수 있다.
- 오른쪽이나 왼쪽영역을 정리할 때 사용하게 되면 최솟값의 변동이 있을때만 사용해야 한다.
ex) [1,100,3,9999,99991]에서 3을 살리려는 풍선일 때 왼쪽 영역인 1,100에서 더 작은 풍선인 1을 터트림으로 마지막으로 남는 풍선이 [1,3,9999]에서 [100,3,9999]로 마지막으로 남는 풍선의 대소관계가 바뀌었다.
- 이걸 코드상에서 구분하기는 어렵기 때문에 살리려는 풍선에서 기회를 1번 쓰는게 좋다. 따라서 기회를 1번 쓴다고 치면 살리려는 풍선이 마지막 3개중 제일 크지만 않으면 살릴 수 있다.

- 1차 풀이(메모리제이션)

```
def solution(a):
    # 제일 왼쪽 : 가능
    # 제일 오른쪽 : 가능
    # 중간 : 가능 or 불가능 (왼쪽 요소 오른쪽요소의 최솟값 둘다 중간값보다 작을때)
    n = len(a)
    left_min = [a[0]]
    result = 0
    for i in range(1,n):
        left_min.append(min(a[i],left_min[i-1]))
    
    right_min = [ a[i] for i in range(n)]
    for i in range(n-2,-1,-1):
        right_min[i] = min(right_min[i+1],right_min[i])    
    #print(left_min,right_min)
    for i in range(1,n-1):
        #print(a[i],left_min[i-1],right_min[i+1])
        if a[i] > left_min[i-1] and a[i] > right_min[i+1]:
            continue
        else:
            result += 1
            
    return result + 2
```

- 구글링

```
def solution(a):
    # 큰거 터트리기 작은것 터트리기 bfs 탐색?(x) -> 범위가 큰걸로보아 이분탐색같음..
    # 특정위치에 풍선을 터트리려면  왼쪽범위풍선중 최솟값,풍선,오른쪽풍선범위 최솟값 이렇게 3개중 제일작거나 중간값이여야 터트릴     #수 있다.
    
    # 아이디어 idx 1번부터 탐색시작 하되 오른쪽 범위(2~n-1)의 최솟값을 구하고
    # 오른쪽으로 이동할때마다 왼쪽범위의 최솟값과 비교시켜주면서 갱신
    # 만약 최솟값이 오른쪽으로 넘어갔다면 다시 min으로 오른쪽 범위 갱신 -> 시간초과
    
    # 아이디어 2
    # 제일 작은수 , 두번째로 작은수 구하기 사이는 전부 삭제 -> 사이에있는수는 절떄 터트릴수 없음
    
    # 네번째 작은수 구하기
    
    if len(a) <= 2:
        return len(a)
    answer = 2
    # 최솟값 쌓기 메모리제이션
    l_min = [a[0]]
    r_min = [a[-1]]
    for i in range(1,len(a)):
        if a[i] < l_min[-1]:
            l_min.append(a[i])
        else:
            l_min.append(l_min[-1])
        if a[len(a)-1-i] < r_min[-1]:
            r_min.append(a[len(a)-1-i])
        else:
            r_min.append(r_min[-1])
    r_min.reverse() # r_min은 끝 인덱스기준으로 최솟값을 쌓았으므로 뒤집어준다.
    
    # 찾은 최솟값으로 비교 계산
    for i in range(1,len(a)-1):
        #if l_min[i+1] > a[i] or r_min[i+1] > a[i]:
        #    answer += 1
        if l_min[i-1] < a[i] and r_min[i+1] < a[i]:
            continue
        else:
            answer += 1
    return answer
```
