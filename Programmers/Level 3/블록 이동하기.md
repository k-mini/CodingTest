
# ğŸ“š ë¸”ë¡ ì´ë™í•˜ê¸°

## ğŸ“Œ [ë¬¸ì œë§í¬](https://school.programmers.co.kr/learn/courses/30/lessons/60063)

### ë¬¸ì œ í•´ì„¤

- 2ì¹¸ìœ¼ë¡œ ì´ë£¨ì–´ì§„ ë¡œë´‡ì´ ìˆë‹¤. ì´ ë¡œë´‡ì€ (1,1),(1,2) ìœ„ì¹˜ì— ë†“ì—¬ìˆìœ¼ë©°, íšŒì „í•  ìˆ˜ ìˆë‹¤.(í˜„ì¬ëŠ” ê°€ë¡œ ìƒíƒœ)
- í•´ë‹¹ ë¡œë´‡ì„ (n,n) ìœ„ì¹˜ê¹Œì§€ ìµœì†Œì‹œê°„ìœ¼ë¡œ ì´ë™í•˜ëŠ”ë° ê±¸ë¦¬ëŠ” ì‹œê°„ì„ return í•˜ëŠ” ë¬¸ì œì´ë‹¤.
- boardì˜ ì›ì†ŒëŠ” 0(ì´ë™ê°€ëŠ¥)ê³¼ 1(ì´ë™ë¶ˆê°€)ì´ë‹¤. 
- ë‹¨ íšŒì „í• ë•Œ íšŒì „ì¶• ìœ„ì¹˜ì˜ ëŒ€ê°ì„ ì— ìˆëŠ” ìš”ì†Œê°€ 0ì´ì–´ì•¼ íšŒì „í•  ìˆ˜ ìˆë‹¤.

### ë¬¸ì œ í’€ì´

- ë³´í†µ bfsì—ì„œëŠ” ì¢Œí‘œë°©ë¬¸ìœ¼ë¡œ ì¤‘ë³µì„±ì„ ì²´í¬í•˜ëŠ”ë°, ì—¬ê¸°ì„œëŠ” 2ê°œì˜ ë…¸ë“œ ë•Œë¬¸ì— ì¢Œí‘œë¡œ ë°©ë¬¸ì²˜ë¦¬í•˜ëŠ” ê²ƒì€ ë¶ˆê°€ëŠ¥í•˜ë‹¤. 
ex) ((1,1),(1,2))ì™€ ((1,1),(2,1))ì€ ë‹¤ë¥¸ ìœ„ì¹˜ì´ë‹¤. ê·¸ëŸ¬ë‚˜ (1,1)ì¢Œí‘œê°€ ì¤‘ë³µë˜ì–´ì„œ ì¢Œí‘œë¡œ ì¤‘ë³µì²˜ë¦¬ë¥¼ í•˜ë©´ ì•ì˜ ë‘ ìœ„ì¹˜ë¥¼ êµ¬ë¶„í•  ìˆ˜ ì—†ë‹¤.
- ë”°ë¼ì„œ ì§‘í•©ì„ ì´ìš©í•œë‹¤.
- ì§‘í•©ì— ì¶”ê°€í•  ë•Œ ë…¸ë“œì˜ ì¢Œí‘œë¥¼ ë°”ê¿”ì¤˜ì„œë„ ë„£ì–´ì¤€ë‹¤.(ë¡œë´‡ì˜ ì•ë’¤ê°€ ì—†ì–´ì„œ ê°™ì€ ì˜ë¯¸ì´ê¸° ë•Œë¬¸ì´ë‹¤.) ex) ((1,1),(1,2))ì™€ ((1,2),(1,1))ì€ ê°™ì€ ìœ„ì¹˜ì´ë‹¤.

```
from collections import deque
def can_move(cur1,cur2, new_board):
    Y, X = 0, 1
    cand = []
    # í‰í–‰ì´ë™
    DELTAS = [(-1, 0), (1, 0), (0, 1), (0, -1) ]
    for dy, dx in DELTAS:
        nxt1 = (cur1[Y] + dy, cur1[X] + dx)
        nxt2 = (cur2[Y] + dy, cur2[X] + dx)
        if new_board[nxt1[Y]][nxt1[X]] == 0 and new_board[nxt2[Y]][nxt2[X]] == 0:
            cand.append((nxt1,nxt2))
    
    # íšŒì „
    if cur1[Y] == cur2[Y] : # ê°€ë¡œë°©í–¥ -> ì„¸ë¡œ ì „í™˜
        UP, DOWN = -1, 1
        for d in [UP, DOWN]:
            if new_board[cur1[Y]+d][cur1[X]] == 0 and new_board[cur2[Y]+d][cur2[X]] == 0:
                cand.append( (cur1, (cur1[Y]+d,cur1[X])) )
                cand.append( (cur2, (cur2[Y]+d,cur2[X])) )
    
    else: # ì„¸ë¡œë°©í–¥ -> ê°€ë¡œ ì „í™˜
        LEFT, RIGHT = -1,1
        for d in [LEFT, RIGHT]:
            if new_board[cur1[Y]][cur1[X]+d] == 0 and new_board[cur2[Y]][cur2[X]+d] == 0:
                cand.append( ((cur1[Y],cur1[X]+d ), cur1))
                cand.append( ((cur2[Y],cur2[X]+d ), cur2))
    
    return cand

def solution(board): # ë‹¤ì‹œ í’€ê¸°

    n = len(board)
    new_board = [ [1] * (n+2) for _ in range(n+2) ]
    for i in range(n):
        for j in range(n):
            new_board[i+1][j+1] = board[i][j]
    
    # í˜„ì¬ ì¢Œí‘œ ìœ„ì¹˜ í ì‚½ì…, í™•ì¸ìš© set
    que = deque([((1,1),(1,2), 0)])
    confirm = set([ ((1,1),(1,2)),((1,2),(1,1)) ]) # visited ëŒ€ì‹ 
    
    while que:
        cur1, cur2, count = que.popleft()
        if cur1 == (n,n) or cur2 == (n,n):
            return count
        for nxt in can_move(cur1,cur2,new_board):
            if nxt not in confirm:
                que.append( (*nxt, count + 1) )
                confirm.add( nxt )
                confirm.add( (nxt[1],nxt[0]) )
```
