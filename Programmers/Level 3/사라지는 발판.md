
### 사라지는발판

[문제링크](https://school.programmers.co.kr/learn/courses/30/lessons/92345)

플레이어 A와 플레이어 B가 서로 게임을 합니다. 당신은 이 게임이 끝날 때까지 양 플레이어가 캐릭터를 몇 번 움직이게 될지 예측하려고 합니다.

각 플레이어는 자신의 캐릭터 하나를 보드 위에 올려놓고 게임을 시작합니다. 게임 보드는 1x1 크기 정사각 격자로 이루어져 있으며, 보드 안에는 발판이 있는 부분과 없는 부분이 있습니다. 발판이 있는 곳에만 캐릭터가 서있을 수 있으며, 처음 캐릭터를 올려놓는 곳은 항상 발판이 있는 곳입니다. 캐릭터는 발판이 있는 곳으로만 이동할 수 있으며, 보드 밖으로 이동할 수 없습니다. 밟고 있던 발판은 그 위에 있던 캐릭터가 다른 곳으로 이동하여 다른 발판을 밞음과 동시에 사라집니다. 양 플레이어는 번갈아가며 자기 차례에 자신의 캐릭터를 상하좌우로 인접한 4개의 칸 중에서 발판이 있는 칸으로 옮겨야 합니다.

다음과 같은 2가지 상황에서 패자와 승자가 정해지며, 게임이 종료됩니다.

움직일 차례인데 캐릭터의 상하좌우 주변 4칸이 모두 발판이 없거나 보드 밖이라서 이동할 수 없는 경우, 해당 차례 플레이어는 패배합니다.
두 캐릭터가 같은 발판 위에 있을 때, 상대 플레이어의 캐릭터가 다른 발판으로 이동하여 자신의 캐릭터가 서있던 발판이 사라지게 되면 패배합니다.
게임은 항상 플레이어 A가 먼저 시작합니다. 양 플레이어는 최적의 플레이를 합니다. 즉, 이길 수 있는 플레이어는 최대한 빨리 승리하도록 플레이하고, 질 수밖에 없는 플레이어는 최대한 오래 버티도록 플레이합니다. '이길 수 있는 플레이어'는 실수만 하지 않는다면 항상 이기는 플레이어를 의미하며, '질 수밖에 없는 플레이어'는 최선을 다해도 상대가 실수하지 않으면 항상 질 수밖에 없는 플레이어를 의미합니다. 최대한 오래 버틴다는 것은 양 플레이어가 캐릭터를 움직이는 횟수를 최대화한다는 것을 의미합니다.

아래 그림은 초기 보드의 상태와 각 플레이어의 위치를 나타내는 예시입니다.

<img src="https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/f6c72518-3c10-467e-a2c4-ecbe418c1dd4/02_2022_%E1%84%80%E1%85%A9%E1%86%BC%E1%84%8E%E1%85%A2%E1%84%86%E1%85%AE%E1%86%AB%E1%84%8C%E1%85%A6_%E1%84%89%E1%85%A1%E1%84%85%E1%85%A1%E1%84%8C%E1%85%B5%E1%84%82%E1%85%B3%E1%86%AB%E1%84%87%E1%85%A1%E1%86%AF%E1%84%91%E1%85%A1%E1%86%AB_01.png" width="400" height="400"/>

위와 같은 경우, 플레이어 A는 실수만 하지 않는다면 항상 이길 수 있습니다. 따라서 플레이어 A는 이길 수 있는 플레이어이며, B는 질 수밖에 없는 플레이어입니다. 다음은 A와 B가 최적의 플레이를 하는 과정을 나타냅니다.

플레이어 A가 초기 위치 (1, 0)에서 (1, 1)로 이동합니다. 플레이어 A가 (0, 0)이나 (2, 0)으로 이동할 경우 승리를 보장할 수 없습니다. 따라서 무조건 이길 방법이 있는 (1, 1)로 이동합니다.
플레이어 B는 (1, 1)로 이동할 경우, 바로 다음 차례에 A가 위 또는 아래 방향으로 이동하면 발판이 없어져 패배하게 됩니다. 질 수밖에 없는 플레이어는 최대한 오래 버티도록 플레이하기 때문에 (1, 1)로 이동하지 않습니다. (1, 2)에서 위쪽 칸인 (0, 2)로 이동합니다.
A가 (1, 1)에서 (0, 1)로 이동합니다.
B에게는 남은 선택지가 (0, 1)밖에 없습니다. 따라서 (0, 2)에서 (0, 1)로 이동합니다.
A가 (0, 1)에서 (0, 0)으로 이동합니다. 이동을 완료함과 동시에 B가 서있던 (0, 1)의 발판이 사라집니다. B가 패배합니다.
만약 과정 2에서 B가 아래쪽 칸인 (2, 2)로 이동하더라도 A는 (2, 1)로 이동하면 됩니다. 이후 B가 (2, 1)로 이동, 다음 차례에 A가 (2, 0)으로 이동하면 B가 패배합니다.
위 예시에서 양 플레이어가 최적의 플레이를 했을 경우, 캐릭터의 이동 횟수 합은 5입니다. 최적의 플레이를 하는 방법은 여러 가지일 수 있으나, 이동한 횟수는 모두 5로 같습니다.

게임 보드의 초기 상태를 나타내는 2차원 정수 배열 board와 플레이어 A의 캐릭터 초기 위치를 나타내는 정수 배열 aloc, 플레이어 B의 캐릭터 초기 위치를 나타내는 정수 배열 bloc이 매개변수로 주어집니다. 양 플레이어가 최적의 플레이를 했을 때, 두 캐릭터가 움직인 횟수의 합을 return 하도록 solution 함수를 완성해주세요.


해설:

완전 탐색으로 접근하려고 했으나, 그 전에 최적의 플레이가 잘 이해가 되지 않았다.
이길 수 있는 플레이어는 최대한 빨리 승리하도록 플레이하고, 질 수 밖에 없는 플레이어는 최대한 오래버티도록 플레이한다.
-> 처음부터 이길지 질지 어떻게 판단하지?? 코드를 짜기도 전에 난관에 봉착했다..

구글링을 해보니 게임이론이라는 알고리즘이 사용된 문제이다.

게임이론

게임이론(game theory)은 상호 의존적이고 이성적인 의사결정에 관한 수학적 이론이다. 개인 또는 기업이 어떠한 행위를 했을 때, 그 결과가 게임에서와 같이 자신뿐만 아니라 
다른 참가자의 행동에 의해서도 결정되는 상황에서, 자신의 최대 이익에 부합하는 행동을 추구한다는 수학적 이론을 연구한다.

```

dy = [-1,1,0,0]
dx = [0,0,-1,1]
INF = 987654321

def solution(board, aloc, bloc):
    # 밟지 않은 발판 or 상대플레이어 위치만 이동 가능
    
    # 지는경우 1. 주변에 발판이 없는 경우 2. 상대방이 같은발판에 있다가 먼저 이동하는 경우
    # 이기는경우 1. 상대방이 이동할 발판이 없는 경우 2. 같은 발판에 있다가 내가 먼저 이동하는 경우
    return solve(board, aloc[0], aloc[1], bloc[0], bloc[1])[1]

def in_range(board, y, x): # 해당 좌표가 범위안에 존재하는지 확인하는 함수
    if y < 0 or y>= len(board) or x < 0 or x >= len(board[0]):
        return False
    return True

def is_finished(board, y, x): # 주변에 하나라도 발판이 없으면 True
    for i in range(4):
        ny = y + dy[i]
        nx = x + dx[i]
        if in_range(board, ny, nx) and board[ny][nx]: # 갈 수 있는 곳
            return False
    return True

def solve(board, y1, x1, y2, x2):
    # 승패 여부 , 턴수
    if is_finished(board, y1, x1): # 갈곳이 없으면 
        return [False, 0] # 진다
    
    # 서로 두 위치가 같을 때 이번 턴에 움직이면 무조건 이기므로
    if y1 == y2 and x1 == x2: # 같은위치에 있으면
        return [True, 1] # 이긴다.
    
    min_turn = INF
    max_turn = 0
    can_win = False
    
    # dfs
    for i in range(4):
        ny = y1 + dy[i]
        nx = x1 + dx[i]
        if not in_range(board, ny, nx) or not board[ny][nx]: # 갈 수 없는 곳
            continue
        
        board[y1][x1] = 0
        result = solve(board, y2, x2, ny, nx) # 차레가 바뀜
        board[y1][x1] = 1
        
        # 이 시점에서는 result[0]이 False여야만 현재 턴에서 내가 이길 수 있다.
        if not result[0]: # 상대가 졌다면 -> 내가 이기는 상황
            can_win = True
            min_turn = min(min_turn, result[1]) # 움직임을 최대한 짧게
        elif not can_win : # 상대가 이겼다면 -> 내가 지는 상황
            max_turn = max(max_turn, result[1]) # 움직임을 최대한 오래
    turn = min_turn if can_win else max_turn # 이길 수 있으면 이긴다.
    
    return [can_win, turn + 1]
   ```
   
   
이번 문제는 어려워서 구글링을 통해 따라치고 분석하는 식으로 진행 하였다.

```
for i in range(4):
        ny = y1 + dy[i]
        nx = x1 + dx[i]
        if not in_range(board, ny, nx) or not board[ny][nx]: # 갈 수 없는 곳
            continue
        
        board[y1][x1] = 0
        result = solve(board, y2, x2, ny, nx) # 차레가 바뀜
        board[y1][x1] = 1
        
        # 이 시점에서는 result[0]이 False여야만 현재 턴에서 내가 이길 수 있다.
        if not result[0]: # 상대가 졌다면 -> 내가 이기는 상황
            can_win = True
            min_turn = min(min_turn, result[1]) # 움직임을 최대한 짧게
        elif not can_win : # 상대가 이겼다면 -> 내가 지는 상황
            max_turn = max(max_turn, result[1]) # 움직임을 최대한 오래
    turn = min_turn if can_win else max_turn # 이길 수 있으면 이긴다.
    
    return [can_win, turn + 1]
```
뒤에 이 부분에서 이해가 잘 가지 않았는데, 각각의 상황에서 끝 노드까지 진입하면 결국 질것인지 이길것인지 알 수 있다. 
끝 노드에서 결과를 받아와서 분기점에서 비교한다.
이기면 이긴 상황에 맞는 최소 이동거리를 저장하고, 지면 진 상황에 맞는 최대 이동거리를 저장한다.
하나라도 이길 수 있으면(True값을 하나라도 받아오면) 내가 이길 수 있는 상황을 만들 수 있으므로 받아온 이긴상황과 그에 이동한 횟수를 비교해서
최솟값으로 저장한다. 진 

 if is_finished(board, y1, x1): 
        return [False, 0]  -> 지는 상황은 이동할 수가 없으므로 거리값 0 을 반환 -> 0번 이동하고 졌다.는 결과를 부모노드에게 전달
    
if y1 == y2 and x1 == x2: 
    return [True, 1] -> 이동 할 수 있는 위치로 이동하면 되므로 거리값 1을 반환  -> 1번 이동하고 이겼다.는 결과를 부모노드에게 전달
        
return [can_win, turn + 1] #   이동횟수 : 자식노드중에 이길 수 있는 최적의 이동횟수 + 함수를 호출하면서 이동 한칸 했으므로 (+ 1)
