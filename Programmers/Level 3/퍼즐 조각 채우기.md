
# ğŸ“š í¼ì¦ ì¡°ê° ì±„ìš°ê¸°

## ğŸ“Œ [ë¬¸ì œë§í¬](https://school.programmers.co.kr/learn/courses/30/lessons/84021)

### ë¬¸ì œ í•´ì„¤

- ê²Œì„ë³´ë“œ í…Œì´ë¸” game_boardì™€ í¼ì¦ ì¡°ê°ì´ ë†“ì¸ í…Œì´ë¸” tableì´ ìˆë‹¤. tableìœ„ì˜ í¼ì¦ ì¡°ê°ì„ game_boardì— ì±„ì›Œ ë„£ì„ ê²½ìš° ì´ ëª‡ ì¹¸ì„ ì±„ìš¸ ìˆ˜ ìˆì„ì§€ return í•˜ëŠ” ë¬¸ì œì´ë‹¤.
- ë‹¨, í¼ì¦ ì¡°ê°ì„ ì±„ìš¸ë•Œ ìƒˆë¡œ ì±„ì›Œ ë†“ì€ í¼ì¦ ì¡°ê°ê³¼ ì¸ì ‘í•œ ì¹¸ì´ ë¹„ì–´ìˆìœ¼ë©´ ì•ˆëœë‹¤.

### ë¬¸ì œ í’€ì´

- êµ¬í˜„ ë¬¸ì œì´ê¸´í•˜ë‚˜ êµ¬í˜„í• ê²Œ ë§ë‹¤.
1. í¼ì¦ì„ íšŒì „í•˜ëŠ” í•¨ìˆ˜ (rotation)
2. í¼ì¦í…Œì´ë¸”ì—ì„œ í¼ì¦ì¡°ê°ì„ ì°¾ì•„ì„œ ì¢Œí‘œë¡œ ë°˜í™˜í•˜ëŠ” í•¨ìˆ˜(bfs íƒìƒ‰ì§„í–‰)
3. ì¢Œí‘œë“¤ë¡œ ì •ì‚¬ê°í˜•ì˜ ë°°ì—´ì„ ë§Œë“œëŠ” í•¨ìˆ˜(trans_puzzle)
4. ì •ì‚¬ê°í˜•ìœ¼ë¡œ ë°”ê¾¼ ë°°ì—´ì„ game_board í…Œì´ë¸”ê³¼ ë§¤ì¹˜ì‹œì¼œë³´ëŠ” í•¨ìˆ˜(is_match)
5. í¼ì¦ ì¡°ê° ì¸ì ‘í•œ ê³³ì— ë¹„ì–´ìˆëŠ” ì§€ì—­ì´ ìˆëŠ”ì§€ í™•ì¸í•˜ëŠ” í•¨ìˆ˜(empty_side)

- 11ë²ˆ í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ ì‹œê°„ ì´ˆê³¼

```
dx = [0,0,-1,1]
dy = [1,-1,0,0]

def rotation(puzzle): # ì‹œê³„ë°©í–¥
    n = len(puzzle)
    m = len(puzzle[0])
    result = [[0] * n for _ in range(m)]
    for r in range(n):
        for c in range(m):
            result[c][n-1-r] = puzzle[r][c]
    return result
            
def bfs(i,j,table ,check):
    puzzle = []
    n = len(table)
    q = [(i,j)]
    check[i][j] = True
    while q:
        x, y =q.pop()
        puzzle.append([x,y])
        for k in range(4):
            nx, ny = x+ dx[k], y + dy[k]
            if not (0 <= nx < n and 0<= ny < n):
                continue
            if not check[nx][ny] and table[nx][ny] == 1: # ì²´í¬ë˜ì§€ì•Šê³  ë¸”ëŸ­ì´ ìˆëŠ”ê³³
                q.append((nx,ny))
                check[nx][ny] = True
    
    return puzzle

# ì¢Œí‘œë¦¬ìŠ¤íŠ¸ë¡œ ë°°ì—´ë§Œë“¤ê¸°
def trans_puzzle(puzzle_location):
    r_min, r_max = 100, -1
    c_min, c_max = 100, -1
    for location in puzzle_location:
        r, c = location
        r_min = min(r_min, r)
        r_max = max(r_max, r)
        c_min = min(c_min, c)
        c_max = max(c_max, c)
        
    r_len = r_max - r_min + 1
    c_len = c_max - c_min + 1
    trans = [[0] * c_len for _ in range(r_len) ]
    for location in puzzle_location:
        x = location[0] - r_min
        y = location[1] - c_min
        trans[x][y] = 1
    
    return trans

def empty_side(game_board,puzzle,i,j):
    n = len(game_board)
    for x in range(len(puzzle)):
        for y in range(len(puzzle[0])):
            if puzzle[x][y] == 1: # í¼ì¦ë¡œ ì±„ì› ìœ¼ë©´ ì¸ì ‘í•˜ëŠ”ì§€ì—­ì´ 0ì¸ì§€ ì¡°ì‚¬
                for k in range(4):
                    nx, ny = (x+i) + dx[k] , (y+j) + dy[k]
                    if not (0 <= nx < n and 0 <= ny < n):
                        continue
                    if game_board[nx][ny] != 1:
                        return True # ë¹ˆ ê³³ì´ ì¡´ì¬
    return False #ë¹ˆ ê³³ì´ ì¡´ì¬í•˜ì§€ ì•ŠìŒ

def is_match(puzzle, game_board):
    n = len(game_board)
    r = len(puzzle) # í¼ì¦ì˜ ê°€ë¡œê¸¸ì´
    c = len(puzzle[0]) # í¼ì¦ì˜ ì—´
    for i in range(n-r+1):
        for j in range(n-c+1):
            match = True
            for x in range(len(puzzle)): # i,j ì§€ì ì—ì„œ ì¡°ì‚¬ ì‹œì‘
                for y in range(len(puzzle[0])):
                    game_board[x+i][y+j] += puzzle[x][y]
                    if game_board[x+i][y+j] != 1:
                        match = False
            
            if empty_side(game_board,puzzle,i,j):
                match = False
            
            if match:
                return True
            else:
                for x in range(len(puzzle)):
                    for y in range(len(puzzle[0])):
                         game_board[x+i][y+j] -= puzzle[x][y]
    return False

def solution(game_board, table):
    n = len(game_board)
    answer = 0
    puzzles = [] # í¼ì¦ í–‰ë ¬ë¡œ ë³€í™˜í•´ì„œ ëª¨ì•„ë†“ì€ ë°°ì—´
    check = [[False] * n for _ in range(n)]
    puzzle_sum = []
    # ë¸”ë¡ì°¾ê¸°
    for i in range(n):
        for j in range(n):
            if table[i][j] == 1 and not check[i][j]: # ë¸”ë¡ì´ìˆëŠ”ë° í™•ì¸ì•ˆí•œêµ¬ì—­
                puzzle_location = bfs(i,j,table,check) # ë¸”ë¡ìœ„ì¹˜ ë°°ì—´ë¡œ ë°˜í™˜
                puzzle = trans_puzzle(puzzle_location)
                puzzles.append(puzzle)
                puzzle_sum.append(len(puzzle_location)) # í¼ì¦ ë„“ì´ ì €ì¥
                
    for idx, puzzle in enumerate(puzzles): # í¼ì¦ í•˜ë‚˜ì”© êº¼ë‚´ì„œ ëŒë ¤ê°€ë©´ì„œ ë¹„êµ
        for _ in range(4):
            puzzle = rotation(puzzle)
            if is_match(puzzle, game_board):
                answer += puzzle_sum[idx]
                break
    
    return answer
```

- ë‹¤ë¥¸ ì‚¬ëŒì˜ í’€ì´ (numpy ì‚¬ìš©)

- pull_left_top => ì¶”ì¶œí•œ êµ¬ë© ë˜ëŠ” ë¸”ë¡ë“¤ì˜ ì§‘í•©ì„ ì¢Œì¸¡ìƒë‹¨ìœ¼ë¡œ ë°€ì°©ì‹œí‚¤ê¸°
- block_split => í•´ë‹¹ ì¢Œí‘œì™€ ì´ì–´ì ¸ìˆëŠ” ë¸”ë¡ì§‘í•©ì„ bfsíƒìƒ‰ì„ í†µí•´ êº¼ë‚´ê¸°. ì¤‘ë³µ ì¶”ì¶œì´ ë˜ì§€ì•Šê²Œ block\[nx][ny] = 1 ì²˜ë¦¬
- blocks => ê°œìˆ˜ë³„ ë¸”ë¡ ì§‘í•©ì„ ë„£ì–´ë‘” ë”•ì…”ë„ˆë¦¬
- holes = > ê°œìˆ˜ë³„ êµ¬ë© ì§‘í•©ì„ ë„£ì–´ë‘” ë”•ì…”ë„ˆë¦¬
- blocks,holesì˜ ë”•ì…”ë„ˆë¦¬ê°€ 1ì—ì„œ 6ê¹Œì§€ì¸ ì´ìœ ëŠ” í¼ì¦ ì¡°ê°ê³¼ ë¹ˆì¹¸ì€ ìµœì†Œ 1ê°œì—ì„œ ìµœëŒ€ 6ê°œê¹Œì§€ ì—°ê²°ëœ í˜•íƒœë¼ê³  ë¬¸ì œì— ë‚˜ì™€ìˆìŒ.

```
import numpy as np
from collections import deque

def pull_left_top(d:np.array):
    while np.count_nonzero(d[:,:1]) == 0:
        d = np.roll(d,shift=-1,axis=1)
    while np.count_nonzero(d[:1,:]) == 0:
        d = np.roll(d,shift=-1,axis=0) 
    return d
def block_split(block, x, y):
    q = deque()
    q.append((x,y))
    visit = np.zeros_like(block)
    block[x][y] = 0
    visit[x][y] = 1
    dx = [0,0,-1,1]
    dy = [-1,1,0,0]
    l = len(block)
    
    while q:
        x,y =q.popleft()
        for k in range(4):
            nx = x + dx[k]
            ny = y + dy[k]
            if nx < 0 or ny < 0 or nx >= l or ny >= l: continue
            
            if block[nx][ny] == 1 and visit[nx][ny] == 0:
                q.append((nx,ny))
                visit[nx][ny] = 1
                block[nx][ny] = 0
    
    return pull_left_top(visit)

def match(hole,block):
    for _ in range(4):
        block = pull_left_top(np.rot90(block))
        tmp = hole - block
        if np.count_nonzero(tmp) == 0:
            return True
    return False

def solution(game_board, block):
    # blocks
    block = np.array(block,int)
    blocks = {1:[],2:[],3:[],4:[],5:[],6:[]}
    for i in range(len(block)):
        for j in range(len(block)):
            if block[i][j] == 1:
                b = block_split(block, i, j)
                blocks[np.count_nonzero(b)].append(b)
                
    # holes
    hole = 1 - np.array(game_board,int)
    holes = {1:[], 2:[], 3:[], 4:[], 5:[], 6:[]}
    for i in range(len(block)):
        for j in range(len(block)):
            if hole[i][j] == 1:
                h = block_split(hole, i, j)
                holes[np.count_nonzero(h)].append(h)
    result = 0
    
    for i in range(1,7):
        for h in holes[i]:
            for j ,b in enumerate(blocks[i]):
                if match(h,b):
                    result +=i
                    blocks[i].pop(j)
                    break
    return result
```
