
# ğŸ“š ì–‘ê³¼ ëŠ‘ëŒ€

## ğŸ“Œ [ë¬¸ì œë§í¬](https://school.programmers.co.kr/learn/courses/30/lessons/92343)

### ë¬¸ì œ í•´ì„¤

- íŠ¸ë¦¬êµ¬ì¡°ì˜ ë…¸ë“œë§ˆë‹¤ ì–‘ê³¼ ëŠ‘ëŒ€ê°€ ì¡´ì¬í•œë‹¤.
- ë£¨íŠ¸ë…¸ë“œ (0ë²ˆ ë…¸ë“œ)ì—ì„œ ì‹œì‘í•˜ì—¬ ìì‹ ë…¸ë“œë¡œ ì´ë™í•  ë•Œë§ˆë‹¤ ì–‘ê³¼ ëŠ‘ëŒ€ë¥¼ ì–»ëŠ”ë‹¤.
- ëŠ‘ëŒ€ì˜ ìˆ˜ê°€ ì–‘ì˜ ìˆ˜ë³´ë‹¤ ê°™ê±°ë‚˜ í¬ë©´ ì–‘ì€ ëª¨ë‘ ì¡ì•„ë¨¹íˆê²Œ ëœë‹¤. ë”°ë¼ì„œ, ì–‘ì´ ëŠ‘ëŒ€ì—ê²Œ ì¡ì•„ë¨¹íˆì§€ ì•Šê²Œ í•˜ë©´ì„œ ìµœëŒ€í•œ ë§ì€ìˆ˜ì˜ ì–‘ì„ ëª¨ì•„ì„œ ë‹¤ì‹œ ë£¨íŠ¸ë…¸ë“œë¡œ ëŒì•„ì˜¤ë ¤ í•œë‹¤.
- ì´ ë•Œ ëª¨ì„ ìˆ˜ ìˆëŠ” ì–‘ì€ ìµœëŒ€ ëª‡ ë§ˆë¦¬ì¸ì§€ returní•˜ëŠ” ë¬¸ì œì´ë‹¤.

### ë¬¸ì œ í’€ì´

- bfs íƒìƒ‰ì˜ ê²½ìš° íƒìƒ‰í•  ìˆ˜ ìˆëŠ” ë…¸ë“œë¥¼ ë‹¨ìˆœíˆ í˜„ì¬ ìˆëŠ” ë…¸ë“œê°€ ì•„ë‹ˆë¼ ì—¬íƒœê¹Œì§€ ë°©ë¬¸í–ˆë˜ ë…¸ë“œë¥¼ ê³„ì† ì €ì¥í•˜ì—¬ ì•ìœ¼ë¡œì˜ íƒìƒ‰ê°€ëŠ¥í•œ ì§€ì—­ì„ ê³„ì† ìµœì‹ í™” ì‹œì¼œì¤€ë‹¤.

- bfs í’€ì´

```
from collections import deque
from collections import defaultdict
def solution(info, edges):
    answer = 0
    G = defaultdict(list)
    #for i in range(len(info)):
    #    G[i] = []
    for edge in edges:
        src, dst = edge
        G[src].append(dst)
        
    q = deque([ [[0],1,0] ]) # [ì—¬íƒœê¹Œì§€ ë°©ë¬¸í•œ ë…¸ë“œë¦¬ìŠ¤íŠ¸, ì–‘ì˜ ìˆ˜, ëŠ‘ëŒ€ ìˆ˜]
    while q:
        nodes, sheep, wolf = q.popleft()
        answer = max(answer,sheep)
            
        for node in nodes:
            for nxt in G[node]:
                if nxt not in nodes:
                    n_sheep,n_wolf = sheep, wolf
                    if info[nxt] == 0:
                        n_sheep += 1
                    else:
                        n_wolf += 1
                        
                    if n_sheep > n_wolf:
                        q.append([nodes + [nxt], n_sheep, n_wolf])      
    
    return answer
```

- dfs (ê¸°ì¡´ ë°©ë¬¸í•œ ì§€ì—­ê¹Œì§€ ë°©ë¬¸í•  ìˆ˜ ìˆëŠ” dfs, ìƒì„¸í•œ ê²½ë¡œ)

```
def getCanGoEdges(i,prev,graph):
    canGoEdges = [node for node in prev if node != i] # ì§€ê¸ˆìˆëŠ”ê³³ ë¹¼ê³  ê°ˆìˆ˜ ìˆëŠ” ì§€ì—­
    for j in range(len(graph)):
        if graph[i][j] == True:
            canGoEdges.append(j)
    return canGoEdges

def DFS(i,s,w,prev,graph,info):
    global answer
    canGoEdges = getCanGoEdges(i, prev, graph)
    if s == w or not canGoEdges:
        if answer < s:
            answer = s
        return
    for edge in canGoEdges:
        if info[edge] == 0:
            DFS(edge, s + 1, w, canGoEdges, graph, info)
        else:
            DFS(edge, s, w + 1, canGoEdges, graph, info)

def solution(info,edges):
    global answer
    answer = 1
    graph = [[False] * len(info) for _ in range(len(info))]
    for x, y in edges:
        graph[x][y] = True
    DFS(0,1,0,[0],graph, info)
    return answer
```

- dfs (ê¸°ì¡´ ë°©ë¬¸í•œ ì§€ì—­ë‚´ì—ì„œ ì´ë™í•˜ëŠ” ê²ƒì€ ìƒëµí•œ dfs)
```
def DFS(i,s,w,prev,graph,info):
    global answer
    if w >= s:
        return
    answer = max(answer,s)
    nodes = prev+[i]
    
    for node in nodes:
        for nxt in graph[node]:
            if nxt not in nodes:
                #n_sheep,n_wolf = sheep,wolf
                if info[nxt] == 0:
                    DFS(nxt,s+1,w,nodes,graph,info)
                else:
                    DFS(nxt,s,w+1,nodes,graph,info)
    
def solution(info, edges):
    global answer
    answer = 1
    graph = [ [] for _ in range(len(info))]
    for x, y in edges:
        graph[x].append(y)
    DFS(0,1,0,[0],graph,info) # í˜„ì¬ ë…¸ë“œ,ì–‘ì˜ ìˆ˜, ëŠ‘ëŒ€ ìˆ˜, ë…¸ë“œë°©ë¬¸ê¸°ë¡, ê·¸ë˜í”„, ë…¸ë“œ ì •ë³´
    return answer
```
