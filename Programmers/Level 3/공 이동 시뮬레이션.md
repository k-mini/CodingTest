
# 📚 공 이동 시뮬레이션

## 📌 [문제링크](https://school.programmers.co.kr/learn/courses/30/lessons/87391)

### 문제 해설

- 2차원 배열 행과 열의 정보 n,m 도착위치 x,y 그리고 시작위치에서부터 순서대로 날려야 할 쿼리 queries 배열이 주어진다.
- 이 때 해당 쿼리들을 순서대로 실행했을 때, x행 y열에 도착하는 시작점의 갯수를 return 하는 문제이다.
- 공이 경계선밖으로 나갈 순 없다. (최대 경계선까지 이동가능)

### 문제 풀이

- 도착지점으로부터 거꾸로 실행해 가면서 가능한 지점을 넓혀나간다.
- 단, 쿼리마다 실행하면서 불가능한 경우가 있다. 예를들어 \[0,0,볼,0,0\] 이렇게 중간에 목표 도착점이 있는데 왼쪽으로 5번이동하는 명령이 있다.  
이 명령은, 어느 지점에서도 실행이 불가능하다. 따라서 쿼리를 실행해보고 불가능한 쿼리이면 답을 0으로 return 한다.

- 임의의 시작에서 dist를 이동해서 x,y를 도착하기 위해선, (x,y)에서 -dist를 이동하는 것과 같다. 그러나 잘 생각해보면 도착점에서 dist로 역으로 이동하는 것 뿐만 아니라  
범위로 인식되는 경우가 있다. 예를들어 0,0에 도착하기 위해서 <- <- 쿼리가 하나 있을때 시작점은 (0,1),(0,0),(0,2) 이다. 이러한 특징은 도착점이 경계선에 존재하여 쿼리의 움직임이
무의미해지는 지점일 때이다. 경계점이 아닌 도착점인 (0,1)은 <- <- 쿼리로 이동할때 가능한 시적점은 (0,3)밖에 없다. 

- 도착점이 하나면 거꾸로 생각해보기가 쉽다. 그러나 문제를 보면 쿼리가 여러 개 주어지며 역으로 한번 실행해보면 범위로 도착점이 넓혀진다. 범위는 뭐 다른가 생각할 수 있다.  
범위로 생각해도 똑같다. 위의 예시에서 쿼리를 한번 역으로 실행하면서 도착점에서 도착 범위로 확장된 것이라고 생각하면 된다.  
(0,0)에 도착하기 위한 시작점 찾기 -> (0,0),(0,1),(0,2)에 도착하기 위한 시작점 찾기로 바뀐 것이다.  
범위도 마찬가지로 x축 방향(<- , ->)으로 이동하는 쿼리를 역으로 생각해야 할때 도착범위가 경계선이 있다면 범위를 확장시키면 되고,  
범위에 경계선이 걸쳐져 있지 않다면, 범위를 그대로 이동시키면 된다. (빵틀을 그대로 이동시킨다고 생각)

1. 예시 1 \[0,1,1,0,0\] 해당 위치가 도착 범위, <- <- 쿼리, 해당 범위를 도착하는 시작점을 구해야 할 때, 오른쪽으로 -> -> 이동시킨다.  
\[0,1,1,0,0\] => \[0,0,0,1,1\]으로 도착범위가 변경되었다.

2. 예시 2 \[1,1,0,0,0\] 해당 위치가 도착 범위, <- <- 쿼리, 해당 범위를 도착하는 시작점을 구해야 할 때, 도착범위는 경계점에 걸쳐 있으므로 쿼리의 움직임이 동작하지 않는 경우도 고려해야 한다.  
오른쪽으로 -> 이동, ->->이동하는 경우가 있다.
\[1,1,0,0,0\] => \[0,1,1,0,0\]와 \[0,0,1,1,0\]가 있다. 두 범위를 합치면 \[0,1,1,1,0\]이 된다.


```
def solution(n, m, x, y, queries):
    answer = 0
    x_min, x_max, y_min, y_max = x, x, y, y
    
    queries = queries[::-1]
    
    for direction,dist in queries :
        if direction == 0: # 열 번호의 감소 -> 열 증가
            y_max += dist
            if y_max > m-1:
                y_max = m-1
            if y_min != 0:
                y_min += dist
                
        elif direction == 1: # 열 번호의 증가 -> 열 감소
            y_min -= dist
            if y_min < 0:
                y_min = 0
            if y_max != m-1:
                y_max -= dist
                
        elif direction == 2: # 행 번호의 감소 -> 행 증가시켜준
            x_max += dist
            if x_max > n-1: 
                x_max = n-1
            if x_min != 0:
                x_min += dist
                
        else: # 행 번호 증가 -> 역으로 행 감소
            x_min -= dist
            if x_min < 0:
                x_min = 0
            if x_max != n-1:
                x_max -= dist
        if y_min > y_max or x_min > x_max:
            return answer
    else:
        answer = (y_max - y_min + 1) * (x_max - x_min + 1)
    return answer
```
