
# ğŸ“š ë“±êµ£ê¸¸

## ğŸ“Œ [ë¬¸ì œë§í¬](https://school.programmers.co.kr/learn/courses/30/lessons/42898)

### ë¬¸ì œí•´ì„¤

- ê°€ì¥ ì™¼ìª½ ìœ„ ì§‘(1,1)ì—ì„œ ê°€ì¥ ì˜¤ë¥¸ìª½ ì•„ë˜ í•™êµ(m,n)ê¹Œì§€ ìµœë‹¨ê±°ë¦¬ë¡œ ì´ë™í•  ë•Œ ìµœë‹¨ê²½ë¡œì˜ ê°¯ìˆ˜ë¥¼ return í•˜ëŠ” ë¬¸ì œì´ë‹¤.

### ë¬¸ì œí’€ì´

- bfsë¥¼ ì´ìš©í•œ í’€ì´ (ì‹œê°„ ì´ˆê³¼, íš¨ìœ¨ì„±í…ŒìŠ¤íŠ¸ x)

```
from collections import deque
def solution(m, n, puddles):
    dx = [1,0]
    dy = [0,1]
    maps = [ [ 0 for _ in range(m) ] for _ in range(n)]
    
    for x,y in puddles:
        maps[y-1][x-1] = -1
    #maps[0][0] = 1
    q = deque()
    q.append((0,0))
    while q:
        x,y =q.popleft()
        
        for k in range(2):
            
            nx= x + dx[k]
            ny= y + dy[k]
            
            if 0 <= nx <= m-1 and 0 <= ny <= n-1 and maps[ny][nx] != -1:
                maps[ny][nx] += 1
                q.append((nx,ny))
    #print(maps)
    return maps[n-1][m-1] % 1000000007
```
ê¸°ì¡´ì— ìµœë‹¨ê±°ë¦¬ë¥¼ êµ¬í• ë•ŒëŠ” maps[ny][nx] = maps[y][x] + 1 ì˜€ìœ¼ë‚˜ ì´ë²ˆì—ëŠ” ê²½ìš°ì˜ìˆ˜ë¥¼ ì¶”ê°€í•˜ëŠ” ê²ƒì´ë¯€ë¡œ maps[ny][nx] += 1(ë…¸ë“œì˜ ë°©ë¬¸ íšŸìˆ˜) ì´ë‹¤.

- dpë¥¼ ì´ìš©í•œ í’€ì´

```
def solution(m, n, puddles):
    
    dp = [ [ 0 for _ in range(m+1) ] for _ in range(n+1)]
    
    for x,y in puddles:
        dp[y][x] = -1
    dp[1][1] = 1
    
    for x in range(1,m+1):
        for y in range(1,n+1):
            #print(dp[y][x])
            if dp[y][x] != -1:
                dp[y][x] += (0 if dp[y-1][x] == -1 else dp[y-1][x]) + (0 if dp[y][x-1] == -1 else dp[y][x-1])   
            else:
                continue
    #print(dp)
    return dp[n][m] % 1000000007
```

