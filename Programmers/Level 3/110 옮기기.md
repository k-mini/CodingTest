
# 📚 110 옮기기

## 📌 [문제링크](https://school.programmers.co.kr/learn/courses/30/lessons/77886)

### 문제 해설

- 배열 s의 각 요소에는 0과 1로 이루어진 문자열 x가 있다. x를 특정 행동을 통해서 최대한 사전 순으로 앞에 오도록 만들어야 한다.
- x에 있는 '110'을 뽑아서 임의의 위치에 다시 삽입한다.
- 예를들어 x = '11100'일 때, 여기서 중앙에 있는 '110'을 뽑으면 '10'이 된다. 여기서 뽑은 '110'을 맨 뒤에 넣으면 '10110'이 되는데 '10110'은 '1100'보다 사전 순으로 앞에 온다.
- 다음과 같은 행동을 통해, 변형시킬 문자열이 사전순으로 최대한 앞에 오도록 하는게 문제이다. 

### 문제 풀이

- 사전순으로 제일 작다 => 0과 1로 이루어진 같은 자릿수를 가진 이진수중에 가장 작은 수를 구하라. => 0을 최대한 왼쪽으로 이동시켜라로 문제를 치환할 수 있다.
- 각 문자열 마다 '110'을 추출해야 하는데 스택을 이용한다.
- '110'을 모두 추출하면 남은 숫자는 '101001010111'와 같이 이루어진다. => 1이 두번 연속 나오면 뒤에 '0'이 존재할 수 없다.(이미 추출했기 때문에)
- '110'을 추출하면 남은 포함한 문자열중 어디에 넣어야 할까? => 남은 자리수 중에 0을 최대한 왼쪽에 옮기려면 남은 0 오른쪽에 넣는것이 좋다. 
- 가장 오른쪽 0의 바로 오른쪽에 삽입하는 것이 가장 좋다
왜냐하면 '0'을 최소 한개 포함하는 자릿수('000','010','100','110')중에 '110'이 가장 사전순으로 뒤에 있거나 같으므로 있으므로 기존의 '0'이 있는 자리수를 뺏어서 '0'이 오른쪽으로 밀려나면 손해이기 때문이다.
- 또한 가장 마지막 '0'의 오른쪽에 넣어주므로 새로 넣어주는 '110'의 '0'을 가장 높게 넣어주려면 바로 오른쪽에 넣는게 '110'의 '0'을 가장 높게 유지할 수 있다.
- 또한 가장 마지막 '0'이 '110'의 '0'으로 바뀌므로 결국 문자열의 마지막 부분은 '110110110110'... 이런식으로 이어지게 되어있다.
- 삽입 -> 추출 -> 삽입 -> 추출이 아닌 한꺼번에 '110'을 추출해서 '110110110...' 이런식으로 넣어줄 수 있다.

- '110' 하나씩 뽑고 넣어주는 것과 스택에서 '110'을 한꺼번에 뽑고 한꺼번에 넣어주는 것은 결과상 차이가 없다.  
(왜일까? => 문자열에서 '110'이 발생하는 지점은 맨처음 문자열 중에 존재하는 경우 그리고 문자열에서 '110'을 추출할 때 새로운 '110'이 나온다.  
새로운 위치에 넣어줄 때도 발생하나 이 때 발생하는 '110'은 사전순으로 앞에 배치하기 위해 넣은 '110'이므로 추출하면 안된다.
뒤에서 설명하겠지만 '110'을 넣어줄 때 '0'이 있는 3자리수 중에 가장 순위가 낮으므로, '0'이 있는 가장 마지막 자리수 바로 오른쪽에 넣어준다. 그래야 기존의
0의 자리수를 제일 놓게 유지하면서 새롭게 넣어주는 0도 높은 자릿수를 유지 할 수 있다.
그림처럼 추출 -> 삽입 -> 추출 -> 삽입 으로 작업을 진행하면 삽입하면 생기는 '110'을 빼주고 추출해야하는 번거로움이 생기고 인덱스 처리가 복잡하다.  
따라서 스택을 이용하여 추출작업만 우선적으로 반복하면서 발생할 수 있는 모든 '110'의 갯수을 저장해주고 
추출 -> 추출 -> 추출 -> .... -> 추출 후 마지막에 한꺼번에 '110'을 삽입해주는 것이 낫다.)
 
- 그럼 삽입을 어디에 해줘야 할까?
삽입하는 자리의 3자리를 사전순으로 비교해보면 다음과 같다.
'000' > '001' > '010' > '011' > '100' > '101' > '110' > '111'  => '110'이 0이있는 3자리 숫자들중 가장 순위가 낮다.
스택으로 추출을 모두 진행하면 남는 숫자는 '110'을 추출할 수 없는 숫자들만 남는다. 즉, 임의로 3자리를 선택했을 때 '0'이 하나로 존재하면 그 자리는 사전순으로 앞인 숫자이다. 
따라서 넣는 3자리에 0이 하나라도 존재하면 사전순으로 뒤로 밀리므로, 문자열 오른쪽부터 탐색하여 0이 있는 자리수 바로 오른쪽에 '110'을 넣어줘야 사전순을 앞으로 당길 수 있다.
ex) '10011111'에 '110'을 넣는다면 0바로 오른쪽에 넣어야 한다. '100' + '110'(여기에 삽입) + '11111' => '10011011111'
 

```
def solution(s):
    answer = []
    
    # 순서  000 > 001 > 010 > 011 > 100 > 101 > 110 > 111  => 110이 0이있는 숫자들중 가장 순위가 낮음
    # 110을 다뺀다 -> 어떤자리든 3자리로 자르면 110은 없다 -> 곧 0이 하나라도 있으면 110보다 큰 3자리가 나온다.
    # 0이 가장 오른쪽에 있는 위치 다음에 110을 넣으면 된다.
    # 1자리와 비교  0 (11) < 110  1(11) > 110
    # 2자리와 비교  0x (1) < 110  10 (1) < 110  11(1) > 110
    # 결론: 0이 하나라도 있으면 110은 마지막 0의 위치 다음에 넣어주면 된다.
    
    for bin_num in s:
        cnt = 0 # 110 개수
        idx = 0
        stack = []
        for w in bin_num:
            if w == '0' and stack[-2:] == ['1','1']:
                stack.pop()
                stack.pop()
                cnt += 1
            else:
                stack.append(w)
        bin_num = ''.join(stack)
        #print(bin_num,cnt)
        
        # 0이 마지막으로 있는곳 찾기
        if bin_num.rfind('0') != -1: # 0이 있다면
            idx = bin_num.rfind('0')
            answer.append( bin_num[:idx+1] + '110' * cnt  + bin_num[idx+1:] )
        else: # 0이 없다면 1로만 이루어졌으므로 제일 왼쪽에 넣기
            answer.append( '110' * cnt + bin_num)
        

    return answer
```
