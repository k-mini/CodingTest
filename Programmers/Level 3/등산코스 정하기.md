
# ğŸ“š ë“±ì‚°ì½”ìŠ¤ ì •í•˜ê¸°

## ğŸ“Œ [ë¬¸ì œë§í¬](https://school.programmers.co.kr/learn/courses/30/lessons/118669)

### ë¬¸ì œ í•´ì„¤

- ì‚°ì€ nê°œì˜ ì§€ì ìœ¼ë¡œ ì´ë£¨ì–´ì ¸ ìˆë‹¤. ê° ì§€ì ì€ 1ë¶€í„° nê¹Œì§€ ë²ˆí˜¸ê°€ ë¶™ì–´ ìˆìœ¼ë©°, ì¶œì…êµ¬, ì‰¼í„°, í˜¹ì€ ì‚°ë´‰ìš°ë¦¬ì´ë‹¤.
- ê° ê²½ë¡œë§ˆë‹¤ ê°€ëŠ” costê°€ ë‹¤ë¥´ë‹¤.
- ì¶œì…êµ¬ì—ì„œ ì‚°ë´‰ìš°ë¦¬ê¹Œì§€ ê°€ëŠ” ê²½ë¡œì˜ intensityê°’ì„ ê°€ëŠ” ê²½ë¡œì¤‘ ê°€ì¥ í° costì˜ ê°’ì„ intensityë¡œ ì •í•˜ê¸°ë¡œ í–ˆë‹¤.
- ì¶œì…êµ¬ ì¤‘ í•˜ë‚˜ì—ì„œ ì¶œë°œí•˜ì—¬ ì‚°ë´‰ìš°ë¦¬ ì¤‘ í•œ ê³³ë§Œ ë°©ë¬¸í•œ ë’¤ ë‹¤ì‹œ ì›ë˜ì˜ ì¶œì…êµ¬ë¡œ ëŒì•„ì˜¤ëŠ” ë“±ì‚° ì½”ìŠ¤ë¥¼ ì •í•˜ë ¤ê³  í•œë‹¤.
- ì´ ë•Œ itensityê°€ ìµœì†Œê°€ ë˜ë„ë¡ í•˜ëŠ” ë“±ì‚°ì½”ìŠ¤ë¥¼ return í•˜ëŠ” ë¬¸ì œì´ë‹¤. (ìµœì†Œì¸ ê²½ë¡œê°€ ì—¬ëŸ¬ê°œë©´ ì‚°ë´‰ìš°ë¦¬ ë²ˆí˜¸ê°€ ê°€ì¥ ì‘ì€ ë“±ì‚°ì½”ìŠ¤ë¥¼ ì„ íƒ)

### ë¬¸ì œ í’€ì´

- gateì˜ ê° ì •ì ì„ ê¸°ì¤€ìœ¼ë¡œ ë‹¤ìµìŠ¤íŠ¸ë¼ ì•Œê³ ë¦¬ì¦˜ì„ ì‹¤í–‰í•œë‹¤.

- ë‹¤ìµìŠ¤íŠ¸ë¼ ì•Œê³ ë¦¬ì¦˜ 1

```
from heapq import heappush
from heapq import heappop
from collections import deque
from collections import defaultdict
def solution(n, paths, gates, summits):
    
    heap = []
    answer = [0,1e9]
    graph = defaultdict(list)
    s_set = set(summits)
    for src,dst,cost in paths:
        graph[src].append([dst,cost])
        graph[dst].append([src,cost])
    
    distance = [ float('inf') for i in range(n+1)]
    
    for gate in gates:
        distance[gate] = 0
        heappush(heap,[0,gate])
    
    while heap:
        intensity, node= heappop(heap)
        
        if intensity > distance[node] or node in s_set:
            continue
        
        for nxt,nxt_cost in graph[node]:
            
            if max(intensity,nxt_cost) < distance[nxt] :
                distance[nxt] = max(intensity,nxt_cost)
                heappush(heap,[max(intensity,nxt_cost),nxt])
            
                
    #print(distance)
    summits.sort()
    for s in summits:
        #print(s,distance[s],answer[1])
        if distance[s] < answer[1]:
            answer = [s,distance[s]]
    return answer
```

- ë‹¤ìµìŠ¤íŠ¸ë¼ ì•Œê³ ë¦¬ì¦˜ 2

```
from heapq import heappush
from heapq import heappop
from collections import deque
import sys
def solution(n, paths, gates, summits):
    INF = sys.maxsize
    nodes = [[] for _ in range(n+1)]
    summits_set = set(summits)
    for path in paths:
        node1, node2, cost = path
        nodes[node1].append([node2, cost])
        nodes[node2].append([node1, cost])
        
    pq = []
    distances = [INF for _ in range(n+1)] # ê°ê°ì˜ ìœ„ì¹˜ì— ë„ì°©í–ˆì„ë•Œ ìµœì†Œ ê°€ì¤‘ì¹˜
    for gate in gates:
        heapq.heappush(pq, [0,gate])
        distances[gate] = 0
    
    while pq:
        cur_cost, cur_node = heapq.heappop(pq)
        if cur_cost > distances[cur_node]: continue # ë„£ì€ ìˆœê°„ê³¼ ë‹¬ë¦¬ ë” ë¹ ë¥¸ ê²½ë¡œë¡œ ìµœì‹ í™”ë˜ì—ˆì„ìˆ˜ë„ìˆìœ¼ë¯€ë¡œ
        
        for next_node, next_cost in nodes[cur_node]:
            total_cost = max(next_cost,cur_cost) # ë‹¤ìŒ ë…¸ë“œë¡œ ì§„í–‰ì‹œ ê°€ì¤‘ì¹˜ ë¹„êµ
            if total_cost < distances[next_node]: # í˜„ì¬ ê°€ì¤‘ì¹˜ê°€ ë” ì ì„ë•Œë§Œ ìµœì‹ í™” ì‹œì¼œì¤€ë‹¤. ë†’ìœ¼ë©´ ë“¤ì–´ê°ˆ í•„ìš” x
                #ë”°ë¼ì„œ ì¶œì…ë¡œëŠ” ì•Œì•„ì„œ ê°€ì§€ ì•ŠëŠ”ë‹¤.
                distances[next_node] = total_cost 
                if next_node not in summits_set: # ì‚°ë´‰ì˜¤ë¦¬ê°€ ì •ìƒì´ë¯€ë¡œ íƒìƒ‰í•˜ì§€ì•ŠìŒ
                    heapq.heappush(pq, [total_cost,next_node]) # ë” íƒìƒ‰í•  ë…¸ë“œë§Œ ë„£ì–´ì¤€ë‹¤.
    
    answer = [-1,INF]
    summits.sort()
    
    for summit in summits:
        if answer[1] > distances[summit]:
            answer = [summit, distances[summit]]
    return answer
```

- 3ì°¨ í’€ì´

```
from heapq import heappush
from heapq import heappop
from collections import defaultdict
def solution(n, paths, gates, summits):

    heap = []
    answer = []
    graph = defaultdict(list)
    s_set = set(summits)
    for a,b,cost in paths:
        graph[a].append((b,cost))
        graph[b].append((a,cost))
    distance = [ float('inf') for i in range(n+1)]
    for gate in gates:
        heappush(heap, (0,gate ) )
    
    while heap:
        intensity,node = heappop(heap)
        if intensity > distance[node] : continue
        if node in s_set:
            answer.append( (node,intensity) )
            continue
        
        for nxt,cost in graph[node]:
            if max(intensity,cost) < distance[nxt]:
                distance[nxt] = max(intensity,cost)
                heappush(heap, (max(intensity,cost), nxt) ) 
                
    #print(answer)
    answer.sort(key = lambda x:(x[1],x[0]) )
    return answer[0]
```
