
# ğŸ“š ë¯¸ë¡œ íƒˆì¶œ

## ğŸ“Œ [ë¬¸ì œë§í¬](https://school.programmers.co.kr/learn/courses/30/lessons/159993)

### ë¬¸ì œ í•´ì„¤

- 1 x 1 í¬ê¸°ì˜ ì¹¸ë“¤ë¡œ ì´ë£¨ì–´ì§„ ì§ì‚¬ê°í˜• ê²©ì í˜•íƒœì˜ ë¯¸ë¡œì—ì„œ íƒˆì¶œí•˜ë ¤ê³  í•œë‹¤.
- ê° ì¹¸ì—ëŠ” í†µë¡œ(O),ë²½(X)ìœ¼ë¡œ ì´ë£¨ì–´ì ¸ ìˆìœ¼ë©° í†µë¡œì—ëŠ” ì‹œì‘ì§€ì (S),ë ˆë²„(L),ì¶œêµ¬(E)ê°€ í•œ ê°œì”© ë†“ì—¬ìˆë‹¤.
- ë¯¸ë¡œì—ì„œ í•œ ì¹¸ì„ ì´ë™í•˜ëŠ”ë° 1ì´ˆê°€ ê±¸ë¦°ë‹¤ê³  í•  ë•Œ, ìµœëŒ€í•œ ë¹ ë¥´ê²Œ ë¯¸ë¡œë¥¼ ë¹ ì ¸ë‚˜ê°€ëŠ”ë° ê±¸ë¦¬ëŠ” ì‹œê°„ì„ êµ¬í•˜ëŠ” ë¬¸ì œ

### ë¬¸ì œ í’€ì´

- ë¬¸ì œ í’€ì´
1. ì‹œì‘ì§€ì ì—ì„œ ë ˆë²„ë¡œ ê°€ëŠ” bfs íƒìƒ‰
2. ë ˆë²„ì—ì„œ ì¶œêµ¬ë¡œ ê°€ëŠ” bfs íƒìƒ‰
3. ë§Œì•½ ë‘ê°œì˜ íƒìƒ‰ ì¤‘ í•˜ë‚˜ë¼ë„ ê±°ë¦¬ë¥¼ êµ¬í•˜ì§€ ëª»í•˜ë©´ íƒˆì¶œí•˜ì§€ ëª»í•˜ë¯€ë¡œ -1ì„ return í•œë‹¤.

```
from collections import deque
def solution(maps):
    
    maps = [ list(i) for i in maps]
    answer = 0
    dx = [-1,1,0,0]
    dy = [0,0,-1,1]
    
    for x in range(len(maps)):
        for y in range(len(maps[0])):
            if maps[x][y] == 'S':
                start_point = (x,y)
            elif maps[x][y] == 'L':
                lever_point = (x,y)
            elif maps[x][y] == 'E':
                end_point = (x,y)
            else:
                continue
                
    def bfs(start,target):
        q = deque()
        q.append((*start,0))
        visited = [ [False] * len(maps[0]) for _ in range(len(maps))]
        while q:
            x,y,dist = q.popleft()
            #print(x,y,dist)
            if (x,y) == target :
                return dist
            
            for k in range(4):
                nx = x + dx[k]
                ny = y + dy[k]
                
                if 0<= nx < len(maps) and 0<= ny < len(maps[0]) and maps[nx][ny] != 'X' and not visited[nx][ny] :
                    visited[nx][ny] = True
                    q.append((nx,ny,dist+1))
        
        return -1
    
    #print(start_point,lever_point,end_point)
    l_route = bfs(start_point,lever_point)
    e_route = bfs(lever_point,end_point)
    if l_route != -1 and e_route != -1:
        answer =  l_route + e_route
    else:
        answer = -1
    return answer
```

- í‹€ë¦° ì½”ë“œ
- ì´ìœ  : q = deque()ì„ bfsíƒìƒ‰ì„ ìƒˆë¡­ê²Œ ì§„í–‰í• ë•Œë§ˆë‹¤ ìƒˆë¡­ê²Œ ì •ì˜ í•´ì¤˜ì•¼ í•œë‹¤.  
ê·¸ë ‡ì§€ ì•Šìœ¼ë©´, ì´ì „ bfs íƒìƒ‰ë•Œ ì§„í–‰í•˜ë˜ ë…¸ë“œê°€ ë‚¨ê²Œë˜ì–´ ë‹¤ìŒ bfsíƒìƒ‰ë•Œ í•´ë‹¹ ë…¸ë“œë¡œ íƒìƒ‰í•˜ê²Œ ë˜ì–´  
ìµœë‹¨ê±°ë¦¬ê°€ ì•„ë‹ˆê²Œ ë‚˜ì˜¬ ìˆ˜ ìˆë‹¤.

- ì˜¤ë¥˜ ì½”ë“œ

```
from collections import deque
def solution(maps):
    
    q = deque()  # ì´ ë¶€ë¶„ì´ ì˜ëª»ë¨
    p_dict = {}
    maps = [ list(i) for i in maps ]
    #print(maps)
    n,m = len(maps),len(maps[0])
    dx,dy = [1,-1,0,0] , [0,0,1,-1]
    def bfs(s,t):
        i,j = s
        visited = [ [False] * m for _ in range(n) ]
        q.append( (i,j,0))
        
        while q:
            x,y,dist = q.popleft()
            
            if (x,y) == t:
                return dist
            
            for k in range(4):
                nx = x + dx[k]
                ny = y + dy[k]
    
                if 0<= nx < n and 0<= ny < m and not visited[nx][ny] and maps[nx][ny] != 'X' :
                    visited[nx][ny] = True
                    q.append((nx,ny,dist+1))
        #return -1
    
    for i in range(n):
        for j in range(m):
            if maps[i][j] in ['S','L','E']:
                p_dict[maps[i][j]] = (i,j)
                
    route1 = bfs(p_dict['S'],p_dict['L'])
    route2 = bfs(p_dict['L'],p_dict['E'])
    
    return (route1 + route2) if route1 and route2  else -1  
```

- ê³ ì¹œ ì½”ë“œ

```
from collections import deque
def solution(maps):
    
    p_dict = {}
    maps = [ list(i) for i in maps ]
    #print(maps)
    n,m = len(maps),len(maps[0])
    dx,dy = [1,-1,0,0] , [0,0,1,-1]
    def bfs(s,t):
        i,j = s
        visited = [ [False] * m for _ in range(n) ]
        q = deque()   # ì—¬ê¸°ë¡œ ì˜®ê¹€
        q.append( (i,j,0))
        
        while q:
            x,y,dist = q.popleft()
            
            if (x,y) == t:
                return dist
            
            for k in range(4):
                nx = x + dx[k]
                ny = y + dy[k]
    
                if 0<= nx < n and 0<= ny < m and not visited[nx][ny] and maps[nx][ny] != 'X' :
                    visited[nx][ny] = True
                    q.append((nx,ny,dist+1))
        #return -1
    
    for i in range(n):
        for j in range(m):
            if maps[i][j] in ['S','L','E']:
                p_dict[maps[i][j]] = (i,j)
                
    route1 = bfs(p_dict['S'],p_dict['L'])
    route2 = bfs(p_dict['L'],p_dict['E'])
    
    return (route1 + route2) if route1 and route2  else -1
```
