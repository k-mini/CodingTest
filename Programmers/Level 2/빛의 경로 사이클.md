
# 📚 빛의 경로 사이클

## 📌 [문제링크](https://school.programmers.co.kr/learn/courses/30/lessons/86052)

### 문제 해설

- 각 칸마다 S, L, 또는 R가 써져 있는 격자가 있다.
- 각 칸마다 써진 문자에 따라 빛이 다음과 같이 이동한다.
    - 빛이 'S'로 써진 칸에 도달할 경우 직진
    - 빛이 'L'로 써진 칸에 도달할 경우 좌회전
    - 빛이 'R'로 써진 칸에 도달할 경우 우회전
- 빛이 끝을 넘어가거나, 처음으로 도달할 경우 반대편 끝쪽에서 다시 돌아온다.
- 해당 격자 내에서 빛이 이동할 수 이는 경로 사이클을 모두 구하려고 한다. 빛의 경로 사이클을 모두 구해 오름차순으로 return 하는 문제. 

### 문제 풀이

- 격자마다 4방향으로 들어올 수 있으므로 (x,y, 빛이 들어오는 방향)인 3차원 좌표를 만들어 bfs 탐색한다.

- 1차 풀이(실패)
- x,y,z 변수를 격자 탐색에도 쓰면서 bfs를 진행할 때도 x,y,z를 쓰면서 변수 설정에 문제가 생겼다.

```
#     ↓ ←  ↑ →
dx = [1,0,-1,0]
dy = [0,-1,0,1]
from collections import deque
def solution(grid): # 감을 못잡겟음
    
    n,m = len(grid),len(grid[0])
    grid = [ list(i) for i in grid ]
    visited = [ [ [False] * 4 for _ in range(m) ]  for _  in range(n)]
    answer = []
    q = deque()
    
    for x in range(n):
        for y in range(m):
            for z in range(4):
                if not visited[x][y][z] :
                    visited[x][y][z] = True
                    q.append((x,y,z))
                    dist = 0
                    while q:
                        x,y,z = q.popleft()
                        dist += 1
                        # 직진
                        if grid[x][y] == 'S':
                            pass
                        # 좌회전
                        elif grid[x][y] == 'L':
                            z = (z-1)%4
                        # 우회전
                        elif grid[x][y] == 'R':
                            z = (z+1)%4
                        nx = (x + dx[z]) % n
                        ny = (y + dy[z]) % m
                        
                        if not visited[nx][ny][z] :
                            visited[nx][ny][z] = True
                            q.append((nx,ny,z))
                            
                    answer.append(dist)
                
    answer.sort()
    return answer
```

- 2차 풀이(변수 지정 다시하니까 정상 통과)

```
#     ↓ ←  ↑ →
dx = [1,0,-1,0]
dy = [0,-1,0,1]
from collections import deque
def solution(grid): # 감을 못잡겟음
    
    n,m = len(grid),len(grid[0])
    grid = [ list(i) for i in grid ]
    visited = [ [ [False] * 4 for _ in range(m) ]  for _  in range(n)]
    answer = []
    q = deque()
    
    for i in range(n):
        for j in range(m):
            for k in range(4):
                if not visited[i][j][k] :
                    visited[i][j][k] = True
                    q.append((i,j,k))
                    dist = 0
                    while q:
                        x,y,z = q.popleft()
                        dist += 1
                        # 직진
                        if grid[x][y] == 'S':
                            pass
                        # 좌회전
                        elif grid[x][y] == 'L':
                            z = (z-1)%4
                        # 우회전
                        elif grid[x][y] == 'R':
                            z = (z+1)%4
                        nx = (x + dx[z]) % n
                        ny = (y + dy[z]) % m
                        
                        if not visited[nx][ny][z] :
                            visited[nx][ny][z] = True
                            q.append((nx,ny,z))
                            
                    answer.append(dist)
                
    answer.sort()
    return answer
```
