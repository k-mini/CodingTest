

## 💰 2차원 동전 뒤집기

[문제링크](https://school.programmers.co.kr/learn/courses/30/lessons/131703)

---

한수는 직사각형 모양의 공간에 놓인 동전들을 뒤집는 놀이를 하고 있습니다. 모든 동전들은 앞과 뒤가 구분되어 있으며, 동전을 뒤집기 위해서는 같은 줄에 있는 모든 동전을 뒤집어야 합니다. 동전들의 초기 상태와 목표 상태가 주어졌을 때, 초기 상태에서 최소 몇 번의 동전을 뒤집어야 목표 상태가 되는지 알아봅시다.


![img](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/7efaaecf-e627-40a8-ab90-60550523ccb0/2%EC%B0%A8%EC%9B%90%201.png)

예를 들어, 위 그림에서 맨 왼쪽이 초기 상태, 맨 오른쪽이 목표 상태인 경우에 대해 알아봅시다. 그림에서 검은색 원은 앞면인 동전, 흰색 원은 뒷면인 동전을 의미합니다. 초기 상태에서 2행과 4행의 돌들을 뒤집으면, 두 번째 그림이 됩니다. 그 후, 2열, 4열, 5열의 돌들을 순서대로 뒤집는 다면, 총 5번의 동전 뒤집기를 통해 목표 상태가 되며, 이 경우가 최소인 경우입니다.

직사각형 모양의 공간에 놓인 동전들의 초기 상태를 나타내는 2차원 정수 배열 beginning, 목표 상태를 나타내는 target이 주어졌을 때, 초기 상태에서 목표 상태로 만들기 위해 필요한 동전 뒤집기 횟수의 최솟값을 return 하는 solution 함수를 완성하세요. 단, 목표 상태를 만들지 못하는 경우에는 -1을 return 합니다.


나의 풀이

    from itertools import combinations
    import copy
    def solution(beginning, target):
        answer = [-1]
        height = len(beginning)
        width = len(beginning[0])
        # 행에서 뒤집을 갯수
        for i in range(len(beginning)+1 ): # 0~ 행의개수까지
            # 열에서 뒤집을 갯수
            for j in range(len(beginning[0])+1 ) : # 0 ~ 행의 개수 까지
                for cols in combinations(range(width), i):
                    cnt = i
                    tmp = copy.deepcopy(beginning)
                    change(tmp,cols,'col')
                    for rows in combinations(range(height), j):
                        change(tmp,rows,'row')
                        if sum(tmp,[]) == sum(target,[]):
                            cnt += j
                            answer.append(cnt)  # 바로 리턴해줘야 함 왜냐하면 1줄을 1번 뒤집을걸 2번더 뒤집을 수 있음
                            return answer # 만약 전부 뒤집는경우가 있으면 경우가 2개임 아예 안 뒤집기 or 행과열 다 선택하는경우
                        change(tmp,rows,'row')
                      
      return -1 if len(answer) == 1 else min(answer[1:] )
  
    def change(beginning,arr,mode):
  
        if mode == 'row':
            for i in arr:
              beginning[i] = [ (num+1) % 2 for num in beginning[i] ]
        else:
            for i in arr:
                for j in range(len(beginning)):
                    beginning[j][i] = (beginning[j][i] + 1) % 2
                    
        return beginning


자꾸 테스트케이스 5번 6번이 오류가 났는데 왜 그런가 곰곰히 생각해보니, 나는 특정한 target은 동전뒤집는 각각의 경우마다 하나씩 가지는 줄 알았는데 아니었다.

2행 한번만 뒤집을 경우 == 2행빼고 모든행 뒤집기 -> 모든열 뒤집기가 같은 경우였다..
오류가 아직 뜨는데 어떻게 좀 더 효율적으로 짜야할지 고민해야겠다.
